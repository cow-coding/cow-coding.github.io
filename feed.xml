<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="https://cow-coding.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://cow-coding.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-09-17T23:45:23+09:00</updated><id>https://cow-coding.github.io/feed.xml</id><title type="html">Coding Gallery</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle><entry><title type="html">[Review] Infcon 2022 참가 후기</title><link href="https://cow-coding.github.io/posts/Infcon2022/" rel="alternate" type="text/html" title="[Review] Infcon 2022 참가 후기" /><published>2022-08-26T17:30:00+09:00</published><updated>2022-08-26T17:30:00+09:00</updated><id>https://cow-coding.github.io/posts/Infcon2022</id><content type="html" xml:base="https://cow-coding.github.io/posts/Infcon2022/"><![CDATA[<h1 id="infcon-2022">Infcon 2022</h1>
<hr />
<h2 id="처음-참가한-컨퍼런스">처음 참가한 컨퍼런스</h2>

<p><img src="/image/Life/infcon/infcon_mail.png" alt="" w="400" /></p>

<p>인프런의 첫번째 개발자 컨퍼런스인 인프콘 2022(INFCON 2022) 참가자에 선정되어 다녀왔습니다. 인프런은 개발자라면 많은 분들이 아실 것이라 생각합니다. 저도 데이터 분석이나 머신러닝, 캐글관련 강의들을 배우는 과정에 많이 사용하기도 했습니다. 많은 개발자들이 사용하는 국내 커뮤니티를 지향하는 인프런의 첫번째 개발자 컨퍼런스는 어떤 내용들이 있을지 기대도 많이 되었고 미리 공개된 세션구성에서부터 듣고 싶은 내용들이 많았습니다.</p>

<p><img src="/image/Life/infcon/ldu.png" alt="" /></p>

<p><img src="/image/Life/infcon/kyh.png" alt="" /></p>

<p><a href="https://infcon.day">인프콘</a> 홈페이지에 들어가면 세션 구성에 대해 안내가 되어 있습니다. 기대한 세션은 인프랩의 CTO인 이동욱님의 발표인 <strong>인프런 아키텍처의 과거와 현재, 그리고 미래</strong>와 인프런의 아이돌 김영한님의 <strong>어느 날 고민 많은 주니어 개발자가 찾아왔다 - 성장과 취업, 이직 이야기</strong>였습니다.</p>

<hr />
<h2 id="인프콘에-도착">인프콘에 도착!</h2>

<p><img src="/image/Life/infcon/infcon_home.jpg" alt="" w="400" /></p>

<p>인프콘은 코엑스 그랜드볼룸에서 진행됐습니다. 코엑스는 가~끔 가봤는데 그랜드볼룸은 어딘지 몰라서 한참을 헤매다가 정문이 아니라 옆문…?으로 들어갔습니다. 다행히 스태프분께서 정문을 안내해주셔서 제대로 스타트를 끊을 수 있었습니다.</p>

<p><img src="/image/Life/infcon/name_card.jpg" alt="" w="400" /></p>

<p>참가 목걸이와 함께 리플렛을 제공되었습니다. 추가로 사진은 없지만 볼펜, 마스크, 스티커, 인프콘 티셔츠를 주머니백에 넣어주셨습니다.</p>

<p>이번 인프콘에서는 핸즈온 세션과 함께 5개의 호실에서 총 31개의 세션이 진행됐습니다. 13:45부터 20분 혹은 40분씩 발표가 진행됐습니다. 4개의 호실에서 동시에 진행됐기 때문에 듣고 싶은 세션들을 정할 필요가 있었습니다.</p>

<p><img src="/image/Life/infcon/partner_list.jpg" alt="" w="400" /></p>

<p>세션들만 진행될 거라 생각했는데, 많은 기업들이 인프콘에 참여해서 굿즈와 채용풀로 인재영입을 진행하기도 했습니다. 부스가 준비된 기업은 총 8개였습니다. 교보문고를 제외한 8개의 기업이 부스가 마련되어 있었고 다양한 굿즈들을 제공해주었습니다.<br />
개인적으로 굿즈 퀄리티는 오늘의 집이랑 토스가 가장 좋았습니다.</p>

<hr />
<h2 id="세션-선택과-이유">세션 선택과 이유</h2>

<p>제가 참가하기로 정한 세션은 다음과 같았습니다.</p>

<p><img src="/image/Life/infcon/pje.png" alt="" />
<img src="/image/Life/infcon/ldu.png" alt="" />
<img src="/image/Life/infcon/velopert.png" alt="" />
<img src="/image/Life/infcon/kdh.png" alt="" />
<img src="/image/Life/infcon/kyh.png" alt="" /></p>

<p>3, 4 세션은 중간에 굿즈들도 받아야 했고 휴식을 좀 취할 필요도 있었어서 넘겼습니다. 데이터와 관련된 내용들을 가볍게 훑어보고 이후에는 서비스 개발에 필요한 아키텍처 구성, 개발자의 성장과 관련된 세션들을 많이 들었습니다.<br />
나름 세션을 선정한 이유는 강연하시는 분들의 명성도 있었고 관심분야도 있었습니다. 간단하게 선정 이유를 설명드리겠습니다.</p>

<h3 id="첫번째-세션">첫번째 세션</h3>
<p><img src="/image/Life/infcon/pje.png" alt="" /></p>

<p>첫 세션은 가볍게 가기로 결정했습니다. 동시간대 다른 강연들에 흥미가 가는 부분은 없기도 했고 같이 간 친구가 듣고 싶어했던 것도 있었습니다. 무엇보다 파이썬을 활용한 데이터 관련 내용들은 제가 잘 알고 있는 부분도 있었기 때문에 너무 복잡하게 생각하지 않아도 될 거라 생각했습니다.<br />
하지만 컨퍼런스에서 조금이라도 무언가를 얻는 게 필요했고 제가 모르는 부분의 라이브러리와 기술적 내용을 얻고자 참여했습니다.</p>

<h3 id="두번째-세션">두번째 세션</h3>
<p><img src="/image/Life/infcon/ldu.png" alt="" /></p>

<p>두번째 세션은 제가 앞서 말한 기대한 세션 중 하나였습니다. 유튜브에서 이동욱님의 영상을 많이 본 것도 있고 말을 굉장히 잘하신다고 생각해서 꼭 듣고 싶었습니다. 그리고 무엇보다 한 기업의 CTO이고 <strong>인프랩이라는 크지 않고 발전하는 기업의 아키텍처와 CTO의 생각</strong>을 보면서 <strong>아키텍처 구성과 기업 발전 과정에서의 고민들을 알고 싶었습니다.</strong></p>

<h3 id="다섯번째-세션">다섯번째 세션</h3>
<p><img src="/image/Life/infcon/velopert.png" alt="" /></p>

<p>리플렛을 제공받기 전까지 김민준님이 누구였는지 기억이 잘 안났습니다. 근데 리플렛에 velopert라는 닉네임이 적힌걸 보고 선택한 부분도 있었습니다. 저 또한 블로그를 하고 있고 어떻게 하면 좀 더 유명하고 유능한 개발자가 될까?를 고민하는 사람이다보니 관련 내용을 어떻게 설계할 수 있을지를 얻고자 참여했습니다.<br />
그리고 무엇보다 지금 시대는 <strong>자기 PR의 시대</strong>라고 불릴만큼 스스로를 잘 어필할 요소들을 만드는게 중요한 시대입니다. 젊은 개발자들에게 인지도가 잘 알려져있는 벨로퍼트님의 발표에서 무언가 얻을 수 있을거라 생각했습니다.</p>

<h3 id="여섯번째-세션">여섯번째 세션</h3>
<p><img src="/image/Life/infcon/kdh.png" alt="" /></p>

<p>다른 세션들도 좋았지만 제가 백엔드 API를 개발할 때 보통 Node.js를 많이 사용하기 때문에 Node.js와 관련된 내용을 선택했습니다. Node.js를 확실히 스타트업단계에서는 많이 사용하는 경향이 있었습니다. 스프링에 비해 빠른 러닝커브를 갖고 있기 때문이 아닐까 생각합니다. Flitto의 개발자이신 강동한님께서도 이런 말을 해주셨습니다.</p>

<h3 id="일곱번째-세션">일곱번째 세션</h3>
<p><img src="/image/Life/infcon/kyh.png" alt="" /></p>]]></content><author><name></name></author><category term="Life" /><category term="Career" /><category term="인프런" /><category term="인프콘" /><category term="inflearn" /><category term="infcon" /><summary type="html"><![CDATA[Infcon 2022 처음 참가한 컨퍼런스]]></summary></entry><entry><title type="html">[Deep Dive Python] 3. Tuple / Dictionary / Set</title><link href="https://cow-coding.github.io/posts/tuple_dictionary/" rel="alternate" type="text/html" title="[Deep Dive Python] 3. Tuple / Dictionary / Set" /><published>2022-07-13T21:30:00+09:00</published><updated>2022-07-13T21:30:00+09:00</updated><id>https://cow-coding.github.io/posts/tuple_dictionary</id><content type="html" xml:base="https://cow-coding.github.io/posts/tuple_dictionary/"><![CDATA[<h1 id="deep-dive-python--tuple--dictionary--set">Deep Dive Python : Tuple / Dictionary / Set</h1>

<hr />

<h2 id="튜플의-특징">튜플의 특징</h2>

<p>튜플은 리스트만큼 많이 사용되는 자료구조이다. 어떤 데이터를 묶음으로 반환하는 많은 함수나 메소드들은 리턴값을 튜플로 반환한다. 그렇기 때문에 튜플에 대한 이해는 리스트 못지 않게 중요하다.</p>

<p>같이 보면 좋은 저장소는 <a href="https://github.com/python/cpython/blob/main/Objects/tupleobject.c">CPython : Tuple Object</a>이다.</p>

<p>참고로 이번 글은 사진보다 글 위주로 될 것이다.</p>

<h3 id="튜플도-객체들의-모음">튜플도 객체들의 모음</h3>

<p>앞서 리스트는 객체 참조자들을 저장하는 컨테이너라고 했다. 튜플은 요소를 순서대로 결합한 요소들의 쌍이다. 리스트와 마찬가지로 여러 자료형들을 함께 저장할 수 있다. 이런 점에서 왜 굳이 리스트와 구분되는 자료형이 있는걸까?<br />
면접에서도 자주 나오는 질문인데, <strong>파이썬에서 리스트와 튜플의 차이점은 무엇일까?</strong></p>

<p>두 자료구조의 가장 큰 차이점은 <strong>값을 수정할 수 있는 가변객체냐, 불변객체냐</strong>이다. 근데 왜 굳이 이게 중요하냐라는 생각이 들 수 있는데, 데이터를 변화시키면 안되는 경우가 존재할 수 있기 때문이다. 파이썬에서 함수의 리턴값을 여러 개로 하면 팩킹의 형태로 변수가 전달된다. 이는 함수가 리턴하면서 혹시 모르게 값이 변화되는 것을 막아줄 수 있다. 그 외에는 리스트와 큰 차이는 없다. 객체의 참조들을 저장하는 특징도 동일하다.</p>

<p>여기서 가변객체냐 불변객체냐는 파이썬의 메모리관리 측면에서 중요한 역할을 한다. 이는 결과적으로 속도와도 연관이 되는데, 다시 <a href="https://cow-coding.github.io/posts/variable/">맨 처음 포스트</a>로 돌아가보면 -5 ~ 256은 미리 만들어진 객체를 사용한다고 했다. 그래서 해당 범위의 수를 사용하는 경우에는 약간이나마 조금 더 시간이 빠르다.</p>

<p>튜플의 특징을 정리하면 다음과 같다.</p>

<ul>
  <li>리스트보다 적은 메모리를 차지하고 성능면에서 더 빠르다.
    <ul>
      <li>리스트보다 적은 메모리를 차지하는 이유는 <a href="https://cow-coding.github.io/posts/list/#리스트의-내부-구조">이전에</a> 말했듯이 리스트는 확장에 대비하고자 좀 더 여유있게 메모리를 확보한다. 하지만 튜플은 내부 구조를 변화하지 않으므로 굳이 메모리를 여유있게 확보할 필요가 없다.</li>
    </ul>
  </li>
  <li>내부 값을 실수로 변경하는 것에 대비할 수 있다.</li>
  <li>딕셔너리 키로 사용가능하다.</li>
</ul>

<h3 id="튜플과-변수">튜플과 변수</h3>

<p>튜플과 리스트를 생성하는 방식에는 각자의 이름을 가진 함수를 호출하는 방식이 있다. 이 둘은 생김새는 동일하지만 동작과정에서 큰 차이가 있다. <strong>이는 결국 가변 객체냐 불변 객체냐로 다시 연결된다.</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">lst1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">lst2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lst1</span><span class="p">)</span>

<span class="n">tp1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">tp2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tp1</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">lst1</code>과 <code class="language-plaintext highlighter-rouge">lst2</code>는 서로 다른 객체가 생성되어 각각의 변수가 참조한다고 했다. 그렇다면 튜플은 어떻게 될까? 아주 잠깐 생각해보면 쉽게 답을 유추할 수 있다. 힌트는 불변 객체이다.</p>

<p>두 튜플의 아이덴티티는 동일하게 나온다. 왜일까? 이는 튜플의 생성 방식때문에 나타난다.</p>

<p><img src="/image/deep/python/tp1.png" alt="" /></p>

<p>튜플은 동일한 튜플 객체에 대해 같은 참조를 하게된다. 이는 튜플이 불변 객체라 어차피 변경을 할 수 없는 데이터라서다. 그래서 같은 실체를 함께 참조하더라도 큰 문제가 발생하지 않기 때문에 동일한 참조를 가리킨다.</p>

<h3 id="튜플의-누적-대입">튜플의 누적 대입</h3>

<p>튜플은 불변 객체라서 누적 대입(<code class="language-plaintext highlighter-rouge">+=</code>)이 불가능할 것 같지만 사용할 수 있다. 하지만 리스트의 누적 대입의 메모리 활용과 다르게 동작한다. 이유는 역시나 불변 객체라서이다.</p>

<p><img src="/image/deep/python/tp2.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">tp1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">tp1</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>누적 대입을 하게되면 새로운 튜플이 만들어지고 객체 참조가 바뀌게 된다. 이 점을 잘 알아둘 필요가 있다.</p>

<p>간단하게 정리하면 튜플은 동일한 객체는 새로 생성하지 않고 참조를 할당하고 조금이라도 변화를 주면 새로운 객체를 만들어서 참조한다.</p>

<hr />

<h2 id="딕셔너리의-특징">딕셔너리의 특징</h2>

<p>딕셔너리도 튜플과 리스트 못지 않게 많이 사용되는 자료구조이다. Key-Value의 쌍으로 이루어진 자료구조이고 자료구조 수업시간에 배우는 딕셔너리 구조를 생각하면된다. 여기서 조금 센스있는 사람 또는 열심히 자료구조 공부를 한 사람이라면 스쳐지나가는 생각이 있다. <strong>딕셔너리는 해시테이블 구조를 가질까?</strong><br />
정답은 <strong>맞다</strong>이다. 딕셔너리는 해시 테이블을 통해 구현되었기 때문에 키 탐색이 빠르다는 장점이 있다.</p>

<h3 id="딕셔너리의-키">딕셔너리의 키</h3>

<p>딕셔너리는 Key-Value가 한 쌍으로 이루어진 자료구조이다. 대부분의 언어에서 Key-Value 쌍의 자료구조에서 Key가 중복되지 않는 고유한 값이어야한다. 이는 파이썬도 마찬가지이다.<br />
우선 딕셔너리는 가변 객체에 속한다. 하지만 딕셔너리의 key는 불변이다. 일반적으로 키에 문자열을 많이 쓰지만 불변 객체라면 모두 사용할 수 있다. 이 말은 <strong>튜플도 키로 쓸 수 있다.</strong></p>

<h3 id="딕셔너리에서-값을-가져올때는-get을-써라">딕셔너리에서 값을 가져올때는 <code class="language-plaintext highlighter-rouge">get</code>을 써라</h3>

<p>이 글을 읽는 대부분의 사람들이 기본적인 딕셔너리 생성이나 사용법은 알 것이라 생각한다. 딕셔너리에서 value를 가져오는 방법은 크게 2가지가 존재한다.</p>

<ul>
  <li>dict[key]</li>
  <li>dict.get(key)</li>
</ul>

<p>둘 중 어떤걸 쓰든 값이 ‘있다면’, 가져오는 데엔 큰 특징은 없다. 하지만 <code class="language-plaintext highlighter-rouge">dict.get(key)</code>로 값을 가져오는 것을 추천한다. 이유는 인덱스식으로 값을 가져올 경우 해당하는 key가 없다면 <code class="language-plaintext highlighter-rouge">KeyError</code> 예외를 발생시킨다. 하지만 <code class="language-plaintext highlighter-rouge">dict.get(key)</code>은 자신이 원한 값은 default로 설정해서 key가 없는 경우 default값을 반환한다. default를 따로 설정하지 않으면 None이 기본으로 설정되어 있다.</p>

<h3 id="딕셔너리-활용">딕셔너리 활용</h3>

<p>딕셔너리에서 <code class="language-plaintext highlighter-rouge">update</code>를 사용하면 딕셔러니를 합치거나 새로운 쌍을 추가할 수 있다. 활용은 아래처럼 사용한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">rgb</span> <span class="o">=</span> <span class="p">{</span><span class="s">"red"</span><span class="p">:</span> <span class="s">"빨강"</span><span class="p">,</span> <span class="s">"blue"</span><span class="p">:</span> <span class="s">"파랑"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">:</span> <span class="s">"초록"</span><span class="p">}</span>
<span class="n">fruit</span> <span class="o">=</span> <span class="p">{</span><span class="s">"yellow"</span><span class="p">:</span> <span class="s">"바나나"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">:</span> <span class="s">"사과"</span><span class="p">,</span> <span class="s">"purple"</span><span class="p">:</span> <span class="s">"포도"</span><span class="p">}</span>

<span class="n">rgb</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">fruit</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>근데 만약 위의 예제처럼 같은 키인데 다른 value를 가지면 어떻게 될까?<br />
update라는 이름에 걸맞게 새롭게 들어오는 key-value 기준에 맞춰 데이터가 바뀌게 된다.</p>

<p><code class="language-plaintext highlighter-rouge">update</code>를 활용하면 특정 키의 요소를 변경하는 것도 가능하다. 이때, <code class="language-plaintext highlighter-rouge">dict.update(key=value)</code>를 적으면 되는데 오타가 아니라 key는 문자열로 적지 않고 key 이름 자체를 적는다.</p>

<hr />

<h2 id="set의-특징">set의 특징</h2>

<p>set은 이름 그대로 집합이다. 중학교에 들어가서 수학책을 피면 가장 맨 처음 만나는 친구가 집합이다. 아마 공부를 아무리 안 한 사람이라도 집합은 공부했을 것이다. 왜냐? 첫 챕터니까…<br />
집합의 가장 큰 특징은 순서와 중복이 없는 값들의 모임이다. 이런 수학적 성질은 파이썬의 set에서도 동일하게 적용된다.</p>

<h3 id="set의-선언">set의 선언</h3>

<p>set을 선언하는 방식은 여러가지가 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">st1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">}</span>
<span class="n">st2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">st3</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>여기서 주의해야할 것은 빈 set을 만들때는 반드시 <code class="language-plaintext highlighter-rouge">set()</code>을 사용해야한다. 이유는 set을 나타내는 연산자는 <code class="language-plaintext highlighter-rouge">{}</code>인데, 만약 빈 <code class="language-plaintext highlighter-rouge">{}</code>을 사용할 경우 빈 딕셔너리가 만들어진다.</p>

<h3 id="set에-대한-이해">set에 대한 이해</h3>

<p>set은 가변 객체이다. 물론 불변 객체로 사용하는 방법도 있다. 이는 fronzeset 타입이 있고 필요에 따라 라이브러리를 활용해 쓸 수 있다. 물론 불변 객체니까 frozenset은 딕셔너리 키로 쓸 수 있다.</p>

<p>set도 값을 추가하거나 삭제할 수 있다. 추가를 할 때는 <code class="language-plaintext highlighter-rouge">set.add(e)</code>를 사용하면 값이 추가된다. 물론 이미 있으면 추가되지 않는다.<br />
제거하는 과정에는 2개의 메소드가 있다. 하나는 <code class="language-plaintext highlighter-rouge">discard</code>, 다른 하나는 <code class="language-plaintext highlighter-rouge">remove</code>이다. 둘 중 어느 것이 좋냐?라는 질문을 한다면, 에러를 발생시키지 않는 쪽이 서비스하기에 유리할 것이다. 그렇다면 <code class="language-plaintext highlighter-rouge">discard</code>를 써야한다. <code class="language-plaintext highlighter-rouge">remove</code>는 값이 없다면 <code class="language-plaintext highlighter-rouge">KeyError</code> 예외를 발생시킨다.</p>

<hr />

<p>파이썬을 깊게 다뤄보는 3번째 시간이었다. 자료형을 그냥 쓰면 되는거지…라는 생각이 들 수도 있는데, 파이썬을 익숙하게 다룬다고 말하거나 다뤄야 한다면 변수가 어떻게 동작하는지, 메모리 구조를 어떻게 처리하는지는 알아야하지 않을까 싶다.</p>]]></content><author><name></name></author><category term="Programming" /><category term="Deep Dive Python" /><category term="Python" /><category term="Programming" /><category term="Tuple" /><category term="Dictionary" /><category term="Set" /><summary type="html"><![CDATA[Deep Dive Python : Tuple / Dictionary / Set]]></summary></entry><entry><title type="html">[Deep Dive Python] 2. List</title><link href="https://cow-coding.github.io/posts/list/" rel="alternate" type="text/html" title="[Deep Dive Python] 2. List" /><published>2022-07-11T23:30:00+09:00</published><updated>2022-07-14T02:31:14+09:00</updated><id>https://cow-coding.github.io/posts/list</id><content type="html" xml:base="https://cow-coding.github.io/posts/list/"><![CDATA[<h1 id="deep-dive-python--list">Deep Dive Python : List</h1>

<hr />

<h2 id="리스트의-특징">리스트의 특징</h2>

<p>리스트는 파이썬을 만나게 된 이후 가장 많이 사용하는 자료구조라고 생각한다. 파이썬에서는 C++이나 Java와 같은 배열 자료구조를 제공하지 않고 그 역할을 리스트가 대신한다. 물론 리스트라는 자료구조는 단순히 배열에 대입해서 보기에는 상당히 복잡한 형태로 구성된 자료구조이다.</p>

<p>같이 보면 좋은 저장소는 <a href="https://github.com/python/cpython/blob/main/Objects/listobject.c">CPython : List Object</a>이다.</p>

<h3 id="리스트는-객체-참조자들의-저장소">리스트는 객체 참조자들의 저장소</h3>

<p><img src="/image/deep/python/list.png" alt="" /></p>

<p>리스트의 활용성이 높은 것은 <strong>다양한 자료형 객체의 저장 컨테이너</strong>라는 것과 <strong>유동적인 데이터 변경</strong>이라는 특징때문이다. 여기서 중요한 것은 객체의 저장 컨테이너라는 점이다. 리스트에 저장되는 모든 요소는 <strong>객체를 참조하는</strong> 역할을 하기 때문에 컨테이너라고 부른다.</p>

<h3 id="리스트와-변수">리스트와 변수</h3>

<p><img src="/image/deep/python/list2.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">lst1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">lst2</span> <span class="o">=</span> <span class="n">lst1</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>앞서 다뤄본 변수에 대한 대입연산은 리스트도 동일하게 이뤄진다. 그렇기 때문에 리스트를 다른 리스트에 대입하는 연산을 수행하는 경우 동일 리스트를 복사하는 것이 아닌 <strong>서로 같은 리스트를 포인팅</strong>하는 것이 된다. 따라서 다른 값을 변경해도 마치 C++의 포인터를 통한 변경처럼 다른 변수에도 영향을 준다.</p>

<p><img src="/image/deep/python/list3.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">lst1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">lst2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>하지만 만약 동일한 리스트 코드를 <strong>각각 생성하면</strong> 다른 객체를 참조한다. 여기까지 다룬 내용들에서도 아주 중요한 것들이 많다. 키워드 문장들을 고르면 다음과 같다.</p>

<ul>
  <li>리스트의 각 요소는 파이썬 객체들을 참조한다.</li>
  <li>리스트는 대입연산을 사용하면 동일 객체를 포인팅한다.</li>
  <li>리스트는 각각 생성하면 다른 객체를 참조한다.</li>
</ul>

<p>이 3가지 핵심 특성은 뒤에서 설명할 리스트 복사의 개념에서 아주 중요한 것들이다. 일단 이렇게 알아두자.</p>

<hr />

<h2 id="리스트의-내부-구조">리스트의 내부 구조</h2>

<h3 id="리스트의-내부">리스트의 내부</h3>

<p>이전에 자료구조에서 <strong>연결 리스트 (Linked List)</strong> 를 배워본 기억이 있을 것이다. 보통 링크드 리스트와 함께 비교하는 자료구조는 배열이 있다. 배열의 장점은 여러가지가 있지만 대표적인 것은 <strong>Random Access가 가능하다는 것</strong>과 <strong>연속적인 메모리 할당으로 빠른 접근 속도</strong>이다. 하지만 그 단점인 유동적인 크기의 변경이 불가능하다는 문제가 있다. 그래서 배열의 장점을 일부 포기하고 확장성을 갖는 자료구조가 바로 링크드 리스트이다. 링크드 리스트의 문제점 중 대표적인 것은 <strong>불연속적인 메모리 할당</strong>이라는 점이 있다.</p>

<p>파이썬의 리스트의 이름을 처음 들으면 링크드 리스트 구조라고 생각할 수 있다. 실제로 리스트의 특징을 갖고 있으며 배열의 특징도 갖고 있어서 단순히 Random Access를 지원하는 링크드 리스트라 생각할 수 있다. 하지만 파이썬의 리스트는 <strong>연속된 메모리에 요소를 저장하는 배열로 동작</strong>한다. 그리고 리스트는 확장에 대비해서 여유있게 메모리를 미리 확보하는 특징이 있다.</p>

<h3 id="대입과-누적-대입">대입과 누적 대입</h3>

<p>리스트를 확장하는 방법으로는 <code class="language-plaintext highlighter-rouge">append</code>, <code class="language-plaintext highlighter-rouge">extend</code>, <code class="language-plaintext highlighter-rouge">x = x + [1]</code> , <code class="language-plaintext highlighter-rouge">x += [1]</code> 과 같은 방식이 있다. <code class="language-plaintext highlighter-rouge">append</code>와 <code class="language-plaintext highlighter-rouge">extend</code>는 기본적으로 기존 리스트의 참조를 확장하는 방식이다. 하지만 누적대입(<code class="language-plaintext highlighter-rouge">+=</code>)과 대입(<code class="language-plaintext highlighter-rouge">=</code>)은 파이썬 내부 동작이 다르게 동작한다. 이 점을 고려하면 좀 더 빠른 연산을 고려할 수 있다.</p>

<p><img src="/image/deep/python/list4.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>기본적으로 대입을 사용하는 리스트 확장은 기존의 파이썬의 대입의 특징을 갖는다. 즉, 새롭게 객체를 만들고 변수는 새로운 객체를 참조한다. 결국 <strong>새로운 객체를 생성</strong>하는 추가적인 시간이 발생한다.</p>

<p><img src="/image/deep/python/list5.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">x</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>하지만 누적대입(<code class="language-plaintext highlighter-rouge">+=</code>)은 기존의 리스트에 확장이 되는 방식으로 연산한다. 따라서 기존 리스트 객체가 변화하지 않는다.</p>

<hr />

<h2 id="리스트-복사">리스트 복사</h2>

<p>리스트를 사용하다보면 가장 많이 마주치는 문제가 바로 리스트 복사 이슈이다. 특히 2차원 배열 형태의 리스트를 사용하면 단순 <code class="language-plaintext highlighter-rouge">list.copy()</code>를 사용하는 것에 문제가 발생하기도 한다. 그래서 좀 더 자세히 리스트 복사와 관련된 내용을 알아보고, 각 방법에 따른 리스트의 구조 변화를 알아보자.</p>

<h3 id="리스트의-단순-복사">리스트의 단순 복사</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>

<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>바로 전 포스팅에서 다뤘던 예제이다. 이 경우 이제는 익숙하겠지만 b는 a 리스트 객체를 참조하기 때문에 a에도 영향을 준다. 리스트의 원본을 유지하면서 변화하는 조작은 프로그래밍에서 상당히 많이 사용되는 기법이다. 보통 변화를 주고 조건 확인 후 문제가 발생하면 원본으로 복구하고, 문제가 없다면 원본에 덮어씌우는 방식에 많이 쓴다. 이런 경우 파이썬은 문제가 될 수 있는 부분들이 있다. 문제들을 해결하고자 파이썬은 <code class="language-plaintext highlighter-rouge">copy</code>와 같은 메소드를 쓴다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>가장 간단한 방법은 <code class="language-plaintext highlighter-rouge">list.copy()</code>를 사용해서 리스트 복사본을 생성하는 것이다. 이렇게 되면 리스트의 동일한 객체를 복사본을 새롭게 생성하여 리턴한다. 즉 새로운 id를 부여받은 객체를 참조한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>또 다른 방법은 <code class="language-plaintext highlighter-rouge">list</code> 함수를 사용해서 <strong>새로운 리스트를 생성</strong>하여 반환하는 것이다. 잠깐 <a href="#리스트와-변수">위로</a> 올라가보면…<br />
리스트의 주요 특징 중 각각 생성한 리스트는 새로운 객체들을 참조한다는 것이 있었다. 결국 이 방식은 완전히 새로운 리스트를 생성하는 것과 동일하기 때문에 복사와 같은 동작을 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>

<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>마지막으로는 리스트 슬라이스를 모든 인덱스로 하면 새로운 리스트가 생성된다. 두 리스트에 대해 객체 비교를 하면 서로 다르게 나타난다. (하지만 튜플은 같다고 나타난다. 이는 이후 설명할 튜플과 딕셔너리에서 다루겠다.)</p>

<h3 id="얕은-복사-깊은-복사">얕은 복사, 깊은 복사</h3>

<p>이제 복사를 알았으니 자유롭게 리스트를 변경할 수 있다고 생각하겠지만… 절반만 맞는 말이다. 파이썬의 변수가 객체를 참조한다는 점에서 참 골치가 아픈 일이 발생한다. 아래 코드의 출력 결과는 과연 뭘까?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위에서 말한 대로라면 <code class="language-plaintext highlighter-rouge">[[1, 2], [3, 4]]</code>가 나와야 하지만, <code class="language-plaintext highlighter-rouge">[[1, 1], [3, 4]]</code>가 된다.</p>

<p>이게 이렇게 되는 이유는 <strong>파이썬의 변수는 객체를 참조한다</strong>는 것과 <strong>리스트는 객체 참조자들의 컨테이너</strong>라는 점때문에 발생한다. 위에서 말한 리스트 복사는 변수가 리스트를 참조만 하는 것을 막기 위해 <strong>동일한 값을 참조하는 참조자들을 저장하는 리스트를 새롭게 만드는 것이다.</strong> 이게 참 머리가 아파지는 부분이다. 이해를 돕고자 그림으로 어떻게 된 상태인지 보여주겠다.</p>

<p><img src="/image/deep/python/copy1.png" alt="" /></p>

<p>간단하게 말하면 우리가 복사하는 리스트는 <code class="language-plaintext highlighter-rouge">PyListObject</code> 객체 자체를 복사한다. 결국 참조자들은 모두 동일하게 유지된다. 그래서 여기서는 매우 특이한 특징이 나타나는데, 앞서 다룬 포스팅에서 -5 ~ 256까지는 동일 숫자 객체를 무조건 지시하지만 범위 밖의 숫자 객체를 매번 새롭게 생성된다고 했다. <strong>하지만 만약 리스트 안에 있는 257은 리스트를 복제하면 다른 객체가 될까?</strong></p>

<p><img src="/image/deep/python/copy2.png" alt="" /></p>

<p>정답을 말하면 <strong>“아니다”</strong> 이다. 이유는 앞서 말한 이유인데, 결국 참조자를 복사하는 것이고 참조자들은 동일 객체를 가리키고 있다. 결국 이런 이유 때문에 앞에 나온 2차원 배열의 문제가 왜 그렇게 나오는지 알 수 있다. 2차원 배열의 구조를 디테일하게 나타내면 아래와 같다.</p>

<p><img src="/image/deep/python/copy3.png" alt="" /></p>

<p>결국 바깥 리스트의 참조자를 복사하는 것은 성공했지만 그 참조자가 가리키는 내부의 리스트는 복사하지 못했기 때문에 발생하는 문제였다. 이 문제를 해결하려면 내부의 리스트 참조자까지 모두 복사를 해야 한다.</p>

<p>이를 위해 <code class="language-plaintext highlighter-rouge">copy</code> 라이브러리의 <code class="language-plaintext highlighter-rouge">deepcopy</code> 메소드를 사용해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">copy</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이렇게 복사를 하면 리스트의 내부까지 복사한 새로운 객체를 만들어서 변수에 할당한다. 따라서 내부의 리스트의 id도 새로 생성한다.</p>

<h3 id="deepcopy-copy에-따른-id-비교">deepcopy, copy에 따른 id 비교</h3>

<p><img src="/image/deep/python/copy4.png" alt="" /></p>

<p>우선 copy로 복사한 경우 얕은 복사가 되며 내부에서 각 리스트의 id를 보면 동일하게 유지되는 것을 볼 수 있다. 이런 구조에서 내부 리스트를 변경하면 그냥 리스트 객체에 참조를 새로 대입한 것과 동일한 것이다.</p>

<p><img src="/image/deep/python/copy5.png" alt="" /></p>

<p>하지만 <code class="language-plaintext highlighter-rouge">deepcopy</code>를 하면 list의 id가 서로 다른 것을 알 수 있다. 이렇게 복사를 하기 때문에 특별한 문제없이 리스트의 변화를 줄 수 있다.</p>

<hr />

<p>리스트는 파이썬에서 가장 많이 다루는 자료형이지만 생각보다 그 내부를 깊이있게 알고 사용하는 사람은 많지 않다. 이는 딕셔너리, 튜플도 마찬가지인데 리스트는 독립적으로 다룰 필요가 있을만큼 내부구조가 복잡하다. 그래서 이번 글에서는 리스트만 따로 분석을 했다. 다음 포스팀에서는 딕셔너리와 튜플을 알아볼 예정이다. 필요에 따라서는 딕셔너리는 따로 분석할 수도 있다.</p>]]></content><author><name></name></author><category term="Programming" /><category term="Deep Dive Python" /><category term="Python" /><category term="Programming" /><category term="List" /><summary type="html"><![CDATA[Deep Dive Python : List]]></summary></entry><entry><title type="html">[Deep Dive Python] 1. Python의 객체와 변수 개념</title><link href="https://cow-coding.github.io/posts/variable/" rel="alternate" type="text/html" title="[Deep Dive Python] 1. Python의 객체와 변수 개념" /><published>2022-07-10T23:30:00+09:00</published><updated>2022-07-12T04:28:07+09:00</updated><id>https://cow-coding.github.io/posts/variable</id><content type="html" xml:base="https://cow-coding.github.io/posts/variable/"><![CDATA[<h1 id="deep-dive-python--python의-객체와-변수의-개념">Deep Dive Python : Python의 객체와 변수의 개념</h1>

<hr />

<h2 id="들어가며">들어가며</h2>

<p>면접 과정에서 파이썬과 관련된 질문을 많이 받았는데, 생각보다 내가 파이썬을 잘 모르고 있다는 사실이 상당히 충격으로 다가왔다. 그래서 기본서로 공부할 책과 좀 더 심화적인 스킬들을 공부할 책을 선정해서 파이썬을 깊게 팔 예정이다. 포스팅 시리즈는 <strong>Deep Dive</strong> 시리즈로 선정했으며 일반적인 파이썬 기초와는 거리가 있을 것이다. Deep Dive Python 시리즈는 다음과 같은 것들을 중점으로 공부할 것이다.</p>

<ul>
  <li>Python의 기초 활용보다는 기초에서는 살~짝 벗어난 관점들</li>
  <li>Python의 메모리 단계까지의 관점</li>
  <li>Python을 더 잘 활용하는 방법</li>
  <li>Python의 효율적으로 활용하는 것</li>
  <li>CPython과 공식문서로 자세한 분석</li>
</ul>

<p>이 글을 읽는 사람이 만약 Python을 처음으로 입문하는 사람이라면 별로 추천하지 않는다. 이 글은 많은 컴퓨터공학적 지식이 기반에 깔려있다고 생각하고 작성하는 글이기 때문이다. 물론 꾸역꾸역 읽으면 어디가서 아는 척하긴 좋겠지만… 딱히 초보자에겐 추천하지 않는다.</p>

<p>Deep Dive Python 첫번째 시리즈로 <strong>Python의 객체와 변수 개념</strong>에 대해 다룰 것이다.</p>

<hr />

<h2 id="python의-객체">Python의 객체</h2>

<h3 id="python의-구현체">Python의 구현체</h3>

<p>우선 Python은 무슨 언어로 구현되어 있을까? Python의 표준 구현체는 C언어로 구현되어 있다. 물론 C++이나 파이썬, Java로 구현된 구현체들도 있지만 표준 구현체는 CPython이고 <a href="https://github.com/python/cpython">python의 공식 레포지토리</a>도 CPython으로 지원한다.</p>

<h3 id="python-object">Python Object</h3>

<p><img src="/image/deep/python/pyobject.png" alt="" /><em>출처 : 나무위키 - 파이썬</em></p>

<p><a href="https://docs.python.org/3/c-api/concrete.html">파이썬 공식문서</a>에 들어가보면 모든 구현체들이 <strong>Python Object</strong>라는 객체로 구현된 것을 볼 수 있다. 이렇게 공식문서를 보면 알 수 있듯이 파이썬은 객체 지향으로 개발된 언어라는 것을 알 수 있다. 그래서 보통 Python 자체를 순수 객체지향 언어라고 부른다.</p>

<p>다만 <strong>파이썬은 객체 지향 언어</strong>라고 표현하는 것은 조심할 필요가 있다. 물론 파이썬이 객체 지향으로 개발된 언어인 것이므로 틀린 말은 아니지만 객체 지향은 프로그래밍 패러다임이기 때문에 사용자의 사용성에 따라 불리는 것이 달라질 수 있다. 파이썬은 절차 지향으로 프로그래밍을 배우기도 하고 상황에 따라서는 함수형 프로그래밍도 가능하다.</p>

<p>파이썬의 객체는 크게 <strong>가변형(Mutable)</strong> 과 <strong>불변형(Immutable)</strong> 로 구분한다.</p>

<ul>
  <li>가변형 : 리스트, 딕셔너리, 집합(set) 등…</li>
  <li>불변형 : 숫자, 문자열, 튜플 등…</li>
</ul>

<p>이런 특징 때문에 파이썬은 <strong>함수에 매개변수를 어떤 것을 전달하냐에 따라</strong> 처리가 달라진다. 불변 객체를 넘겨줄 경우 특수한 처리를 하지 않는다면 Call by Value로 처리하고, 가변 객체를 넘겨주면 Call by Reference로 처리한다. 파이썬 공식문서에서는 <strong>Call by Assignment (할당에 의한 호출)</strong> 와 <strong>Call by Object Reference (객체 참조에 의한 호출)</strong> 이라 한다.</p>

<p>함수에 대한 얘기는 나중에 자세히 파보도록하고 일단 이번 포스팅에서는 <strong>불변 객체 위주의 변수 할당</strong>을 알아보겠다.</p>

<hr />

<h2 id="python의-변수">Python의 변수</h2>

<h3 id="python의-변수와-객체의-관계">Python의 변수와 객체의 관계</h3>

<p>파이썬이든, C++이든 자바든 많은 언어들은 <code class="language-plaintext highlighter-rouge">=</code> 연산자를 활용해서 변수를 선언한다. C++와 같은 언어는 메모리에 변수가 저장되는 방식으로 관리한다. 새로운 변수에 다른 선언된 변수를 할당하면 새로운 메모리에 동일한 객체가 복사되는 방식으로 저장된다. 그래서 만약 동일 메모리의 변수를 가리키고 싶다면 C++은 <strong>포인터(pointer)</strong> 를 사용한다.</p>

<p>여기서 파이썬이 간단해보이지만 꽤 복잡한 언어인 이유가 나타나는데, <a href="https://github.com/python/cpython/tree/main/Objects">CPython의 객체 코드</a>를 뜯어보면 많은 포인터들로 구성되어 있다는 것을 알 수 있다. 일단 간단하게 깔고 들어가면, <strong>파이썬의 변수 대입(<code class="language-plaintext highlighter-rouge">=</code>)은 새로운 메모리 할당이 아니라 객체에 대한 참조이다.</strong></p>

<h3 id="python-객체의-기초-지식">Python 객체의 기초 지식</h3>

<p>여기서부터 조금 복잡해지는데, 우선 기본적으로 알고 가야하는 파이썬 지식 중 하나는 <strong>파이썬에서 -5 ~ 256까지의 수는 이미 만들어진 객체를 할당</strong>한다는 것이다. 이 범위 밖의 정수는 새로 객체를 할당한다. 특이한 점은 같은 257을 두번 할당하면 서로 다른 객체가 선언된다.</p>

<p>여기서 객체의 주소와 비슷한 격인 내용을 확인하려면 <code class="language-plaintext highlighter-rouge">id(변수명)</code>을 사용하면 객체의 아이덴티티를 알 수 있다.</p>

<h3 id="python의-변수-선언">Python의 변수 선언</h3>

<p>파이썬에서 리스트를 사용하다보면 아래와 같은 코드를 짜고 난감한 결과를 경험한 적이 있을 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>

<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위 코드에서 a의 값은 변화가 될까? 라는 질문을 받으면, C++을 메인으로 사용한 사람의 경우 변하지 않는다고 말할 것이다. 하지만 파이썬은 변하게 된다. 이유는 위에서 언급했던 파이썬의 변수 할당 방식때문이다.</p>

<p><img src="/image/deep/python/assign.png" alt="" /></p>

<p>파이썬은 변수에 값을 복사하는 개념이 아니라 <strong>변수가 지시(point)하는 객체가 바뀌는 것</strong>이다. 가끔 그런 생각해본 적 없는가? <strong>“파이썬은 왜 자료형을 선언하는 방식으로 변수를 선언하지 않지?”</strong><br />
파이썬에서 변수의 역할을 생각해보면 자료형을 굳이 선언할 필요가 없다. 왜냐면 파이썬에서 변수는 그냥 지시하는 객체만 바꾸면 되기 때문이다. 우리가 C++이나 자바에서 자료형을 선언하는 이유는 <strong>자료형에 따라 메모리에 할당하는 공간의 크기를 결정하기 때문이다.</strong> 하지만 파이썬은 객체를 생성하고 변수는 객체를 지시만 하면 되므로 그럴 필요가 없는 것이다.</p>

<p>이런 특징과 위에서 언급한 -5 ~ 256까지는 이미 만들어진 객체를 사용한다는 것 때문에 신기한 결과가 나타난다. 같은 257인데, 다르다고 나올 수 있다.</p>

<h3 id="동일성-판단-is">동일성 판단 (<code class="language-plaintext highlighter-rouge">is</code>)</h3>

<p>Python에서는 동일성을 판단하는 연산자가 크게 2가지 종류가 있다. <code class="language-plaintext highlighter-rouge">==</code>와 <code class="language-plaintext highlighter-rouge">is</code> 연산자이다. 일반적으로 프로그래밍 언어는 불필요한 연산자와 기능을 굳이 만들지 않는다. 그렇다면 얼핏 보기에 비슷한 두 연산자가 왜 있을까? 그 이유는 당연하게도 역할이 다르기 때문이다.<br />
자바스크립트를 써 본 사람이라면 <code class="language-plaintext highlighter-rouge">==</code>과 <code class="language-plaintext highlighter-rouge">===</code>의 차이점을 알 것이다. 위 두 연산자의 차이도 이것과 비슷하다.</p>

<p><code class="language-plaintext highlighter-rouge">==</code>은 단순히 <strong>객체 값의 동일성</strong>을 판정하고, <code class="language-plaintext highlighter-rouge">is</code>는 <strong>객체 자체의 동일성</strong>을 판정한다.</p>

<p>아래의 코드의 출력결과는 어떻게 될까?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">c</span> <span class="o">=</span> <span class="mi">257</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">257</span>

<span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">d</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">c</span> <span class="ow">is</span> <span class="n">d</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>물론 눈치 빠른 사람들은 <code class="language-plaintext highlighter-rouge">T</code> <code class="language-plaintext highlighter-rouge">T</code> <code class="language-plaintext highlighter-rouge">T</code> <code class="language-plaintext highlighter-rouge">F</code>라는 것을 알 수 있다. 근데 왜…? 객체가 같지/다르지? 라는 생각이 들 수 있다. 이유는 -5 ~ 256은 이미 만들어진 객체를, 범위 밖의 숫자는 새로 객체를 할당한다. 이런 이유때문에 3은 같게, 257은 다르게 나온다.</p>

<h3 id="del"><code class="language-plaintext highlighter-rouge">del</code></h3>

<p>변수를 제거하는 연산, 특히 dictionary나 리스트에서 제거할때, <code class="language-plaintext highlighter-rouge">del</code> 연산자를 사용하는 것을 본 사람들이 있을 것이다. 이름이 <code class="language-plaintext highlighter-rouge">del</code>이라서 처음 배운 언어가 뭐냐에 따라 메모리 할당 제거를 하는 것이라 생각할 수 있으나 <code class="language-plaintext highlighter-rouge">del</code>의 역할은 <strong>변수와 객체의 연결관계를 분리하는</strong> 것이다.</p>

<p>그렇다면 여기서 사용되지 않는 객체는 어떻게 관리될까?<br />
파이썬은 <a href="https://github.com/python/cpython/blob/ef61b259e35a0249840184b59f43d8a7f9b095bc/Include/object.h#L102-L106">몇 개의 변수가 객체를 참조하고 있는지 관리하는 변수인 <code class="language-plaintext highlighter-rouge">ob_refcnt</code></a>가 있다. 참조 변수가 만약 0이 된다면 파이썬은 일정 시간 후에 메모리를 해제하는 코드를 동작시킨다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">Py_DECREF</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_Py_DECREF_STAT_INC</span><span class="p">();</span>
    <span class="n">_Py_RefTotal</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_refcnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_refcnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_Py_NegativeRefcount</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">_Py_Dealloc</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이런 방식을 써서 파이썬은 메모리를 관리한다.</p>

<hr />

<p>파이썬은 변수만 봐도 굉장히 깊게 공부할 요소들이 많다. 이 부분은 파이썬이 동작하는 과정에서 중요한 부분이다. 변수 컨트롤을 진행하는 요소나 서비스를 개발하는 과정에서 리소스 관리에서도 중요하게 작용한다.</p>

<p>이번에는 불변 객체 위주로 변수를 봤고 다음 포스팅은 가변 객체인 리스트, 딕셔너리, set의 구조와 동작에 대해서 다뤄볼 예정이다.</p>]]></content><author><name></name></author><category term="Programming" /><category term="Deep Dive Python" /><category term="Python" /><category term="Programming" /><category term="Variable" /><summary type="html"><![CDATA[Deep Dive Python : Python의 객체와 변수의 개념]]></summary></entry><entry><title type="html">[Review] 네이버 부스트캠프 AI Tech를 마치며…</title><link href="https://cow-coding.github.io/posts/BCretro/" rel="alternate" type="text/html" title="[Review] 네이버 부스트캠프 AI Tech를 마치며…" /><published>2022-06-28T13:00:00+09:00</published><updated>2022-06-28T13:00:00+09:00</updated><id>https://cow-coding.github.io/posts/BCretro</id><content type="html" xml:base="https://cow-coding.github.io/posts/BCretro/"><![CDATA[<h1 id="네이버-부스트캠프-ai-tech를-마치며">네이버 부스트캠프 AI Tech를 마치며…</h1>

<hr />

<p><img src="/image/boostcamp/last/snow.jpeg" alt="" w="400" /></p>

<blockquote>
  <blockquote>
    <p>눈이 많이 내리던 지난해 겨울에 시작한 부스트캠프는 비가 많이 내리기 시작할 여름에 마무리 됐다.</p>
  </blockquote>
</blockquote>

<p>1월부터 6월까진 진행한 <strong>부스트캠프 AI Tech 3기</strong> 활동을 마무리하며 지난 6개월의 여정을 돌이켜 볼 생각이다.</p>

<h2 id="본격적인-시작">본격적인 시작</h2>

<p>데이터 직군을 희망한다고 남들한테 많이 말했던 거 같은데 막상 ‘누군가한테 설명할 수 있을까?’ 라는 질문을 스스로에게 던졌을 때, yes라는 대답이 바로 나올 수가 없었다. <strong>‘대충이라도 설명할 수 없다’</strong> 라는 것이 나에게 많은 생각을 하게 만들었고 가장 체계적이고 좋은 공부 방법이 무엇일까? 고민하다가 부스트캠프에 지원했다.</p>

<h3 id="오리엔테이션과-첫-느낌">오리엔테이션과 첫 느낌</h3>

<p>오랜 기간을 AI, 데이터 관련으로 준비했어서 자소서를 작성하는데 큰 어려움이 있지 않았다. 자소서를 어떤 느낌으로 썼는지 궁금하다면 <a href="https://cow-coding.github.io/posts/BCTest/">부캠 합격 후기</a>를 확인해 보시길…</p>

<p><img src="/image/boostcamp/last/ot.jpeg" alt="" w="400" /><em>부스트캠프의 시작</em></p>

<p>기대반 걱정반으로 첫번째 OT에 참석했고 첫 데일리 스크럼을 진행했다. Level 1 동안 기초적인 수학, 통계 AI에 대한 지식들을 학습하는 것이 학습목표였고 함께 할 동료들은 부스트캠프 측에서 구성해줬다. 정말 다양한 분야의 사람들이 모였고 항상 컴퓨터공학과 혹은 공대 사람들만 보던 나에게는 새로운 경험이었다.<br />
조교 활동을 하면서 비전공자 사람들을 여러번 상대해본 적은 있지만 아무래도 학교 수업을 듣는 학생들은 <strong>간절함과 진심</strong>이 없는 경우가 많다. 하지만 여기 들어온 사람들은 그때 느끼지 못했던 간절함과 진심을 갖고 있었고 전공자로서 도와줄 수 있는 부분에서 많이 도움을 주고 싶었다.</p>

<h3 id="하루하루-회고를-다지며">하루하루 회고를 다지며…</h3>

<p><img src="/image/boostcamp/last/olympic.jpeg" alt="" w="400" /><em>올 한해 참 많은 스포츠 대회때문에 힘든 부캠을 잘 견딜 수 있었다.</em></p>

<p>Leve 1과 Level 2 기간동안 절대 놓치지 않았던 것들이 있었다. 적어도 강의에서 나온 내용을 최대한 <strong>내 방식으로 기록하자</strong>였다. 내가 부스트캠프를 시작했던 이유는 <strong>내가 하기로 한 분야에 대해서 대충도 설명 못하는데 어떻게 그 분야에서 일할 수 있겠어?</strong> 라는 생각때문이었다. 이런걸 해결하려면 반드시 그날 공부한건 그날 정리했다.</p>

<p>그리고 그날 그날 회고를 꾸준히 기록했다. 정말 큰거부터 정리 시간이 오래 걸린다는 사소한 부분까지 기록했다. 물론 P-stage와 Product Serving에서는 너무 개인 회고를 적는거 보다 프로젝트 개발, 실험 일지를 적는걸로 대체했다.</p>

<p>지금 회고를 적으면서 확인해보니까 벌써 119개의 글을 적었다.</p>

<p><img src="/image/boostcamp/last/write.png" alt="" w="500" /></p>

<p>사실 product serving 파트는 아직 적지 못한 부분이 많아서 시간 여유가 될 때 필기한 내용들을 정리할 예정이다. 또한 추천 시스템 이론도 이원성 마스터님께서 설명해주신 부분들을 자세히 기록하지 못했어서 해당 부분도 다시 정리할 예정이다.</p>

<p>이렇게 다 정리하면 대충 150개 글이 완성될 거 같다. 나름의 방식으로 이해하려 노력했고 최대한 강의 내용을 그대로 적기보다는 추가적인 내용을 덧붙이려 했다. 내용이 많았고 시간적인 부분이 문제가 되는 경우가 많았다. 하지만 내가 얻고 싶은 목표를 달성하고자 꼭 해야할 일 중 하나였다.</p>

<hr />

<h2 id="다양한-대회-경험">다양한 대회 경험</h2>

<h3 id="처음으로-겪은-시작부터-끝">처음으로 겪은 시작부터 끝</h3>

<p><img src="/image/boostcamp/last/hangang.jpeg" alt="" w="500" /><em>중간에 한강뷰 라이브 유튜브 채널을 틀어놓고 지낸 기간도 많았다.</em></p>

<p>운영측에서 꾸려준 팀으로 7주간의 기초교육을 받으며 빈틈밖에 없던 많은 부분을 채워나갔다. 마지막에 진행한 image classification 대회를 맨 처음에 봤을 때는 ‘CV 트랙에게 유리한 대회가 아닌가?’라는 생각이 들었다. 하지만 막상 패를 까보니 NLP팀들이 상위권을 쓸어담고 있었다. 지금도 생각해보면 맨날 최신 트렌드를 알아본다고 MLOps에 대한 관심도 갖고, 정보도 찾아보고 했는데 최근 트렌드인 Data-centric에 대한 접근은 하나도 하지 않았던 것으로 기억한다. 계속 모델에만 인적 리소스를 넣었고 성능 향상도 드라마틱하지는 못했다. 결국 대회 마지막날 모델 output 전수조사를 하면서 데이터 분포를 변경해보면서 성능 향상을 이뤄냈다. <strong>결국 Andrew Ng이 맞았다.</strong> 하지만 나는 알고만 있었고 대입하지 못했다. 이런 것도 결국 내가 초보라는 반증이 아니었나라는 생각이 들었다.</p>

<p>처음으로 PyTorch를 사용해 처음부터 끝까지 하나의 학습 파이프라인을 만들어 본 경험이었고 코드적인 부분, 논문을 적용하는 부분 등 많은 방면에서 경험을 늘릴 수 있던 <strong>시작</strong> 그 자체의 역할을 제대로 했다. 첫 대회를 경험하면서 <strong>사이언티스트와 엔지니어 그 사이 어딘가에서의 방향</strong>에서 어디로 갈 지 결정할 수 있던 계기가 되었다.<br />
확실히 수식이나 이론적인 내용을 다루는 것이 재미는 있었지만 내가 컴퓨터공학과에 진학한 이유를 떠올려보면, 결국 프로그래밍을 통해 스스로 무언가를 만들어 보기 위해서였다. 이 대회를 경험하면서 엔지니어 역할이 내가 가장 바라는 것이라는 걸 알 수 있었다.</p>

<h3 id="추천-시스템-그리고-실수-발전">추천 시스템, 그리고 실수, 발전</h3>

<p><img src="/image/boostcamp/last/recom.jpeg" alt="" w="500" /></p>

<p>Level 2에 들어가면서 본격적으로 추천 시스템 트랙에 대해 심화된 학습을 진행했다. 추천 시스템을 처음으로 만난 것은 지난 해 CLOVA AI RUSH 2021에서였다. 나는 항상 <strong>실제 세계에서 적용되는 것들</strong>을 바래왔다. CV, NLP도 많이 실생활에 적용되고 있지만 추천 시스템만큼 real world가 더 중요한 부분이 없다고 생각했다. 이런 부분이 나를 추천 시스템으로 이끌었던 것 같다. 부스트캠프에서 추천 트랙 강의를 들으면서 가장 많이 들었던 것이 ‘CTR’, ‘실제 서비스 환경’ 같은 단어였다. 대회를 경험하고, 마지막에 서비스를 개발하면서도 같은 추천 시스템이지만 완전히 다른 이슈들을 마주했었다.</p>

<p>Movie recommendation 대회에서도 결국 데이터였고, 이번에는 모델 분석도 꽤 중요했다. 데이터 분석가 역할을 초반에 맡아서 진행했는데, 당시의 실수가 아직도 기억난다. Movie Lens 데이터를 재구성했다는 점때문에 대회에서 말한 sequential 특징을 완전히 무시해버리는 논리를 펼쳤다는 것이다.<br />
지금 돌이켜보면 제일 큰 문제는 데이터를 실제 sequential로 분석해보고 상관관계가 적다는 결과를 낸 것이 아니라 단순히 데이터가 Movie Lens라는 이유로 그랬다. 데이터 분석가라는 사람이 데이터를 철저하게 분석하고 내린 결과가 아닌 직감에 의한 결과라는 것이 문제였다. 이것도 지금보면 결국 초보자, 경험부족에서 발생한 문제였다.</p>

<h3 id="대회를-경험하면서">대회를 경험하면서…</h3>

<p>대회 진행 내용을 자세히 적는건 회고에서는 큰 의미가 없다고 생각한다. 만약 진행내용이 궁금하다면 <a href="https://cow-coding.github.io/categories/p-stage/">P-stage 후기들</a>을 찾아보길 바란다.</p>

<p>대회를 겪으면서 가장 크게 느낀건 <strong>난 진짜 초보자 그 자체였다</strong>라는 것이다. 그리고 대회가 끝나고 나서 <strong>초보자만이 겪을 수 있는 실수였고, 현업에서 겪기 전에 경험했다는 것</strong>이었다. 가장 핵심적인 실수들은 다음과 같았다.</p>

<ul>
  <li>최근 트렌드에 대한 정보를 알아보고, 수집했으나 <strong>실제 적용하지 못함</strong></li>
  <li>데이터에 입각한 분석보다 <strong>직관에 의한 분석이 더 앞섰다.</strong></li>
  <li>확장적인 생각을 할 수 없었다.</li>
</ul>

<p>현업에서 겪기 전이라고 말은 했지만 이 자체도 섣부른 판단일 수도 있다. 아직 현업에서 일해본 적이 없으니 말이다. 내가 가장 초보라고 느낀 부분은 <strong>데이터에 입각한 객관적 분석</strong>을 하지 못했다는 것이었다. 데이터 엔지니어, 사이언티스트, 분석가 등 데이터 직군에서 일하는 사람들은 결국 데이터애 입각한 분석결과를 내야하는 것이었다. 물론 ‘일반적으로 이러이러하니까 이러이러할 것이다’라는 가설을 세울 수는 있지만 결국 <strong>가설</strong>이다. 데이터를 분석하고, 통계적인 수치로 <strong>검정</strong>을 해야하는 것이다. 이 부분은 아직도 많이 부족하다고 생각하고 스스로 경계하는 부분이다.</p>

<p>대회에서 참 많은 스트레스를 받았지만 그만큼 많은 실수를 하면서 여러가지 깨달음을 얻었다. 단순히 지식적인 부분만이 아닌 실수를 통한 경험을 할 수 있다는 것도 장점이었다고 생각한다.</p>

<hr />

<h2 id="서비스를-개발하면서">서비스를 개발하면서…</h2>

<p>부스트캠프의 마지막 과정은 Product Serving이다. 데이터 수집부터 서비스 배포까지 모든 단계를 개발하는 과정이다. 이활석 마스터님도 말씀하셨지만 추천 시스템의 특성상 모델 자체의 방향보다 전체 서비스 아키텍처설계가 중요했다. 또한 LINE, Kakao 등 많은 기업들에서 고민하고 있는 문제인 추천 inference time에 대한 고민도 많이 필요했다. 하지만 Level 3 - Product Serving에서 가장 중요한 것은 대회를 경험할 때와 달리 <strong>모든 것을 내가 다 할 수 없다</strong>라는 것이다.</p>

<p>프로젝트를 진행한 경험이 팀에서 가장 많아서 의도하지 않았지만 PM의 역할을 담당했다. 개발, 모델 연구, 데이터 수집을 한 명이 할 수 없다는 것을 인지하는 것이 가장 중요했고 팀원들의 역할분담을 가장 우선적으로 진행했다. 그리고 여기서부터 내가 할 수 있는 것은 <strong>팀원을 믿는 것</strong>이었다.<br />
물론 매일 데일리 스크럼과 피어세션때 자신의 진행상황을 브리핑하는 것이 있었지만 결국 팀원이 얼마나 자신의 역할을 잘 수행하고 있느냐가 핵심이었다. 물론 팀원들도 나를 믿고 자신의 역할을 하는 것이라 책임감을 가지고 진행했어야 했다. 무엇보다 학습 데이터와 추천 목록에 사용되는 데이터를 수집하는 것이 내 역할이다보니 서비스 개발의 핵심적인 역할이라는 부담이 컸다.</p>

<h3 id="전공기초-지식을-왜-배워야-하는가">전공기초 지식을 왜 배워야 하는가?</h3>

<p>사실 컴퓨터공학을 전공하는 많은 사람들도 전공지식이 실제 서비스 개발에 얼마나 사용될까?라는 생각을 갖는 경우가 많다. 데이터베이스를 배워도 DBMS 프로그램을 사용하고, SQL문을 사용하는 정도이고 내부 구조를 실제 건드리는 경우가 많지 않을 것이라 생각한다. OS를 배워도 어차피 사용하는 OS는 리눅스, 윈도우즈, 맥OS이고 이미 잘 만들어진 OS들이다. 사실 나도 뭔가 쓰인다고는 들었는데 어디서 어떻게 쓰이고 실제 쓰이는 것을 보지도 못했으니 와닿지는 않았다.<br />
하지만 이번 서비스 개발에서 데이터 수집 파이프라인을 구축하면서 전공지식의 필요성을 가장 크게 느꼈다. 기존에 데이터를 수집하는 코드의 방식은 monolithic으로 수집과정 전반에 문제가 발생하면 처음부터 다시 처리해야하는 문제가 있었다. 하지만 데이터를 주기적으로 데이터베이스에 저장한다면, 그런 문제를 조금은 해결할 수 있었다. 또한 API 제한이 발생하면 데이터베이스 저장도 문제가 발생하므로 데이터 수집, 저장을 비동기로 분리해야 했다.<br />
이 과정에서 상당히 고생을 많이 했었다. 서로 다른 코드를 만들면 좋은데, 문제는 연결하는 방법을 몰랐다. 부캠 슬랙에 도움을 요청했고 같은 캠퍼분 중에 관련된 기술로 잘 아시는 분께서 도움을 주셨다. 당시 설명하신 내용은 redis와 같은 message queue를 이용해서 sender-receiver를 사용하는 것이었다. 이 방식은 내가 OS에서 배웠던 프로세스 통신 방법 중 하나였다. 정말 일부분 중 하나였지만 이런 사소한 이해를 얼마나 잘 적용하느냐가 중요하다는 것을 알았다.<br />
이런 부분을 잘 알기 위해서 우리는 전공공부를 하는 것이고 기술면접을 보는 것이라 생각했고 크게 느꼈다.</p>

<p>자세한 내용은 <a href="https://cow-coding.github.io/categories/level-3-final-project/">최종 프로젝트 개발일지</a>를 읽어보길 바란다.</p>

<h3 id="서비스-개발은-현실이다">서비스 개발은 현실이다.</h3>

<p>팀원과의 큰 트러블이 있지는 않았지만 가장 어려웠던 부분도 있었다. 팀원의 구성이 취직 + 대학원(연구)로 나눠져 있었다. 프로젝트를 진행하면서 데이터의 문제, 모델적인 문제들이 많이 존재했었고 심지어는 서비스를 하는 과정에 평가, 소비자의 행동과 같은 문제들도 있었다. 내부 회의에서 수많은 문제들이 제기되었지만 이 문제들을 모두 해결하는 것은 불가능했다. <strong>때로는 현실적으로 바라보면서 일부 문제들은 안고 가야할 필요도 있었다.</strong> 그게 실력적인 문제이든, 시간적인 문제이든 그건 지금 중요하지 않다. <strong>결국 우리는 서비스를 완성해야 한다.</strong> 완벽한 서비스는 없다. 하지만 완벽해지려고 노력할 수는 있다. 노력을 하려면 일단 만들어야한다. 그러니까 때로는 치명적인 문제가 아니면 안고 끝을 보긴 해야 한다는 것을 알았다.</p>

<hr />

<h2 id="마무리">마무리</h2>

<p>회고를 적기는 했는데 이게 회고인지… 그냥 부캠하고 나서 느낀 생각 주저리 주저리 적어놓은건지 잘 구분이 안가기는 한다. 하지만 그만큼 가식을 없애고 가장 있는 그대로 느낀 것들을 적었다.<br />
내가 2년 전에 심리상담을 받으면서 들었던 말이 있다.</p>

<blockquote>
  <p>‘사소한 성공 경험을 하나씩 하는 것이 중요하다.’</p>
</blockquote>

<p>부캠정도의 내용이 사소한 성공 경험은 아니지만 나는 또 새로운 도전 한개를 끝까지 마쳤다. 여러개의 할 수 있는 것들이 생겼고 더 해보고 싶은 많은 것들이 생겼다.</p>

<h3 id="이제는-실전">이제는 실전</h3>

<p><img src="/image/boostcamp/last/airush2022.png" alt="" /></p>

<p>1년 전의 나와 지금의 나를 비교해 볼 수 있는 아주 좋은 기회가 생겼다. 1년 전 AI Rush를 참가했을 때는 아무것도 모르는 운 좋은 사람이었다. 이제는 아니다. 대회, 프로젝트를 경험하면서 <strong>어떻게 공부하고, 모델을 사용하는지</strong>를 배웠다. 잘 배운 것을 이제는 잘 녹여내고 적용해 볼 기회다. 이번 AI Rush도 너무 기대되는 것이 지난 AI Rush 2021에서 내 인생의 방향점을 잡을 수 있었다. 과연 이번에는 어떤 방향점을 줄 지 기대가 된다.</p>

<h3 id="진짜-마무리">진짜 마무리</h3>

<p>사실 어느정도 취업 결과가 나오고 회고를 적으려고 했다.</p>]]></content><author><name></name></author><category term="Life" /><category term="Career" /><category term="네이버" /><category term="NAVER" /><category term="BoostCamp" /><category term="부스트캠프" /><category term="AI Tech" /><summary type="html"><![CDATA[네이버 부스트캠프 AI Tech를 마치며…]]></summary></entry><entry><title type="html">[BoostCamp AI Tech / Final] Day91 - Consumer 코드 확장</title><link href="https://cow-coding.github.io/posts/final8/" rel="alternate" type="text/html" title="[BoostCamp AI Tech / Final] Day91 - Consumer 코드 확장" /><published>2022-06-01T03:00:00+09:00</published><updated>2022-06-01T03:00:00+09:00</updated><id>https://cow-coding.github.io/posts/final8</id><content type="html" xml:base="https://cow-coding.github.io/posts/final8/"><![CDATA[<h1 id="final-project--consumer-code-확장">Final Project : Consumer code 확장</h1>

<hr />

<h2 id="목차">목차</h2>

<ul>
  <li>Consumer code 확장</li>
</ul>

<hr />

<h2 id="consumer-code-확장">Consumer code 확장</h2>

<p><a href="https://cow-coding.github.io/posts/final6/#user-producer--consumer-설계-변경">이전</a>에 Producer-Consumer에 사용되는 Consumer 코드를 <code class="language-plaintext highlighter-rouge">insert</code>와 <code class="language-plaintext highlighter-rouge">update</code>에 맞춰 데이터를 넣어주는 방식을 제안했습니다. 이때, 당시 글에도 남겨놨던 furture question으로 update condition을 넣는 방식을 적었습니다. 이번에 해당 방식을 도입해서 더 확장성 높은 Consumer로 코드를 버전업했습니다.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">if</span> <span class="s">"update"</span> <span class="ow">in</span> <span class="n">msg</span><span class="p">:</span>
    <span class="n">update_data</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="s">"update"</span><span class="p">]</span>
    <span class="n">rid</span> <span class="o">=</span> <span class="n">update_data</span><span class="p">[</span><span class="s">"rid"</span><span class="p">]</span>
    <span class="n">uid</span> <span class="o">=</span> <span class="n">update_data</span><span class="p">[</span><span class="s">"uid"</span><span class="p">]</span>
    <span class="n">conn_repo</span><span class="p">.</span><span class="n">update_one</span><span class="p">({</span><span class="s">"rid"</span><span class="p">:</span> <span class="n">rid</span><span class="p">},</span> <span class="p">{</span><span class="s">"$push"</span><span class="p">:</span> <span class="p">{</span><span class="s">"star_user_list"</span><span class="p">:</span> <span class="n">uid</span><span class="p">}})</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>기존의 consumer의 update 부분은 하나의 기능에 대해서만 동작하는 한계가 있었습니다. 이를 해결하고자 <code class="language-plaintext highlighter-rouge">update_one</code>의 argument를 분석해서 확장성을 높였습니다.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">if</span> <span class="n">update</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>
    <span class="n">update_data</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="s">"update"</span><span class="p">]</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="n">update_data</span><span class="p">[</span><span class="s">"condition"</span><span class="p">]</span>
    <span class="n">query</span> <span class="o">=</span> <span class="n">update_data</span><span class="p">[</span><span class="s">"query"</span><span class="p">]</span>
    <span class="n">conn_repo</span><span class="p">.</span><span class="n">update_one</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>실제 <code class="language-plaintext highlighter-rouge">update_one</code>은 인자로 update 조건과 update query를 받습니다. 즉, Producer에서 condition과 query를 넘겨준다면 정말로 producer만 갈아끼우면 되는 producer-consumer 파이프라인이 만들어집니다.<br />
이렇게 해서 consumer 코드의 개발이 어느정도 진행이 된 것으로 보입니다. 추가적인 기능 개선이 있을 수 있지만 현재의 상태로 충분히 데이터 수집 및 적제를 비동기로 처리할 수 있는 쓰임새만큼 발전되었습니다.</p>]]></content><author><name></name></author><category term="NAVER BoostCamp AI Tech" /><category term="Level 3 - Final Project" /><category term="NAVER" /><category term="BoostCamp" /><category term="AI Tech" /><category term="Proeject" /><category term="Data Engineering" /><category term="MLOps" /><category term="Redis" /><summary type="html"><![CDATA[Final Project : Consumer code 확장]]></summary></entry><entry><title type="html">[BoostCamp AI Tech / Final] Day91 - Airflow setting 및 배치 파이프라인 설계</title><link href="https://cow-coding.github.io/posts/final7/" rel="alternate" type="text/html" title="[BoostCamp AI Tech / Final] Day91 - Airflow setting 및 배치 파이프라인 설계" /><published>2022-06-01T01:00:00+09:00</published><updated>2022-06-10T10:32:19+09:00</updated><id>https://cow-coding.github.io/posts/final7</id><content type="html" xml:base="https://cow-coding.github.io/posts/final7/"><![CDATA[<h1 id="final-project--airflow-setting-및-배치-파이프라인-설계">Final Project : Airflow setting 및 배치 파이프라인 설계</h1>

<hr />

<h2 id="목차">목차</h2>

<ul>
  <li>Airflow setting</li>
  <li>Batch train 파이프라인 설계</li>
</ul>

<hr />

<h2 id="airflow-setting">Airflow setting</h2>

<p>저희 서비스에서 사용하는 추천모델은 크롬 익스텐션을 활용하는 만큼 빠른 반응속도를 보여야 합니다. 따라서 추천 모델들 중 속도가 빠른 편인 VAE 계열의 모델을 사용했습니다. 문제는 VAE 계열의 모델들은 기본적으로 입력을 완선된 형태의 user-item matrix로 사용하므로 신규 유저나 정보의 변화에 대응하기 어렵다는 것입니다. 이를 해결하고자 매시간, 매 2시간마다 주기적으로 배치학습을 진행해서 좋은 성능을 보이는 모델로 새로운 user-item matrix 기반의 학습을 하기로 했습니다.</p>

<h3 id="왜-airflow-인가">왜 Airflow 인가?</h3>

<p><img src="/image/boostcamp/project/airflow.png" alt="" w="500" /></p>

<p>스케줄링 워크플로 툴들은 다양하게 존재합니다. Luigi, Metaflow, Airflow 등이 있습니다. 그렇다면 왜 Airflow를 선택했을까요? 우선 가장 핵심적인 이유는 Python으로 동작한다는 점입니다. 기본적으로 ML/DL을 활용하는 서비스이다보니 Python 기반의 코드가 많습니다. 이를 고려해서 연동성을 생각하면 Airflow가 좋은 선택지로 보였습니다. 또한 현재 거의 스케줄링 툴의 표준이 된 상황이라 적용해 볼 가치가 있었습니다.</p>

<h3 id="data-및-backend-architecture">Data 및 BackEnd Architecture</h3>

<p><img src="/image/boostcamp/project/back.png" alt="" w="500" /></p>

<p>현재 서비스의 백엔드 아키텍처입니다. 전반적인 데이터베이스, 메인 API Server는 GCP를 활용하고 모델 학습 정보를 저장하고자 Cloud storage를 도입했습니다. 관련된 내용은 <a href="https://cow-coding.github.io/posts/final6/#cloud-storage-설정-및-연결-코드-개발">이전 글</a>을 참고해주세요.</p>

<p><img src="/image/boostcamp/project/batch.png" alt="" /></p>

<p>이렇게 배치학습을 하는 부분의 구조는 다음과 같습니다. 기본적으로 RecVAE 코드가 Airflow 서버상에 존재하고 Airflow는 MongoDB Atlas에서 현재 존재하는 repository(item)의 구성을 모두 가져옵니다. 이후 fitering을 거쳐 유의미한 아이템들만 선별하고 RecVAE 학습을 진행합니다.<br />
이렇게 학습이 완료된 모델 정보는 실제 <code class="language-plaintext highlighter-rouge">model.pt</code> 파일과 파일이 저장된 cloud storage 정보로 나눠져서 각각 cloud storage와 MongoDB Atlas로 전달됩니다.</p>

<p><img src="/image/boostcamp/project/model_coll.png" alt="" /></p>

<p>기본적으로 모델 정보를 저장하는 model collection에는 기준 지표가 되는 score와 학습모델, 파일명, 모델이 저장된 버킷명을 저장합니다. 또한 동점 케이스는 최신 모델을 사용하도록 선정했습니다.</p>

<p><img src="/image/boostcamp/project/cloud_storage.png" alt="" /></p>

<p>실제 cloud storage에는 모델의 정보를 담고 있는 <code class="language-plaintext highlighter-rouge">model.pt</code> 파일이 업로드 됩니다. 이 정보들을 활용해서 FastAPI 서버는 주기적으로 모델을 최신, 최고 성능의 모델로 교체합니다.</p>

<hr />

<h2 id="batch-train-파이프라인-설계">Batch train 파이프라인 설계</h2>

<p><img src="/image/boostcamp/project/dag.png" alt="" /></p>

<p>복잡한 구조의 DAG 설계가 필요하지는 않았습니다. 하지만 전처리를 2번 진행해야하는 과정이 있었고 이 과정에서 연속적인 흐름을 진행할 경우 시간 소모의 문제가 있을 수 있었습니다.<br />
따라서 DB에서 repository 정보를 불러와서 user-item matrix를 형성해서 저장하는 <code class="language-plaintext highlighter-rouge">preprocessing_base_data</code> task, 실제 RecVAE에 들어가게 되는 데이터로 전처리하는 <code class="language-plaintext highlighter-rouge">preprocessing_vae</code>로 구별했습니다.<br />
이후 모델을 학습하고 부산물로 나오는 <code class="language-plaintext highlighter-rouge">model.pt</code> 파일에 대한 정보 파싱을 진행했습니다. 모델 정보를 저장하는 규약으로는 <code class="language-plaintext highlighter-rouge">학습모델종류_점수.pt</code>로 지정했으므로 이에 맞춰 model 이름과 score로 파싱하여 이후 모델 정보를 저장하기 위해 <code class="language-plaintext highlighter-rouge">xcom</code>으로 data context를 전달합니다.</p>

<hr />

<h2 id="파이프라인-설계-과정의-이슈와-해결과정">파이프라인 설계 과정의 이슈와 해결과정</h2>

<h3 id="timezone-이슈">Timezone 이슈</h3>

<p>Airflow는 일정 시간을 기준으로 반복을 하는 스케줄링 툴입니다. 따라서 어떤 기준 시각이 존재해야하는데, 일반적으로 UTC기준으로 시간을 산정합니다. 따라서 구동하는 서버의 timezone 설정이 되어 있지 않는다면 일단 우선적으로 timezone 설정 이슈를 만납니다.<br />
우분투 기준, 이를 해결하려면 <code class="language-plaintext highlighter-rouge">tzselect</code>를 활용해 해당하는 시간대로 설정을 해주시면 원활하게 airflow webserver가 구동됩니다.</p>

<h3 id="dag의-timezone을-kst로-세팅하기">DAG의 timezone을 KST로 세팅하기</h3>

<p>역시나 airflow의 <code class="language-plaintext highlighter-rouge">start_date</code>도 UTC를 기준으로 설정됩니다. 이를 해결하고자 다음과 같은 방식으로 작성하면 KST 기준으로 코드를 작성하고 Airflow는 UTC 기반으로 해석합니다.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">pendulum</span>
<span class="kn">from</span> <span class="nn">airflow</span> <span class="kn">import</span> <span class="n">DAG</span>

<span class="n">kst</span> <span class="o">=</span> <span class="n">pendulum</span><span class="p">.</span><span class="n">timezone</span><span class="p">(</span><span class="s">"Asia/Seoul"</span><span class="p">)</span>

<span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span>
    <span class="n">dag_id</span><span class="o">=</span><span class="s">"train_batch"</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s">"RecVAE batch train dag"</span><span class="p">,</span>
    <span class="n">start_date</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2022</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">kst</span><span class="p">),</span>
    <span class="n">schedule_interval</span><span class="o">=</span><span class="s">"@hourly"</span><span class="p">,</span>
    <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s">"recsys"</span><span class="p">,</span> <span class="s">"recvae"</span><span class="p">]</span>
<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<hr />

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://www.bucketplace.co.kr/post/2021-04-13-버킷플레이스-airflow-도입기/">오늘의 집 개발 블로그: 버킷플레이스 Airflow 도입기</a></li>
</ul>]]></content><author><name></name></author><category term="NAVER BoostCamp AI Tech" /><category term="Level 3 - Final Project" /><category term="NAVER" /><category term="BoostCamp" /><category term="AI Tech" /><category term="Proeject" /><category term="Data Engineering" /><category term="MLOps" /><category term="Redis" /><summary type="html"><![CDATA[Final Project : Airflow setting 및 배치 파이프라인 설계]]></summary></entry><entry><title type="html">[BoostCamp AI Tech / Final] Day88 - User 수집, Cloud storage</title><link href="https://cow-coding.github.io/posts/final6/" rel="alternate" type="text/html" title="[BoostCamp AI Tech / Final] Day88 - User 수집, Cloud storage" /><published>2022-05-26T01:00:00+09:00</published><updated>2022-06-02T22:37:58+09:00</updated><id>https://cow-coding.github.io/posts/final6</id><content type="html" xml:base="https://cow-coding.github.io/posts/final6/"><![CDATA[<h1 id="final-project--user-수집-cloud-storage">Final Project : User 수집, Cloud storage</h1>

<hr />

<h2 id="목차">목차</h2>

<ul>
  <li>User producer &amp; consumer 설계 변경</li>
  <li>Cloud Storage 설정 및 연결 코드 개발</li>
</ul>

<hr />

<h2 id="user-producer--consumer-설계-변경">User producer &amp; Consumer 설계 변경</h2>

<h3 id="user-data의-확보">User data의 확보</h3>

<p>지난번에 활용한 producer-consumer 코드로 repository 수집이 완료되었습니다. 이 repository를 활용해서 학습에 사용할 user 데이터를 구축해야 합니다. 여기서 문제는 단순히 아무 유저 정보를 가져올 수도 없을 뿐더러 저희가 갖고 있는 아이템에서 선택한 값이 없다면 기반 모델로 선정한 <strong>RecVAE</strong>를 학습할 수 없는 문제가 있습니다.<br />
이런 문제를 해결하고자 학습 데이터에 한해서는 역으로 데이터를 추출하는 방식을 활용하기로 했습니다.</p>

<p><img src="/image/boostcamp/project/user_get.png" alt="" /><em>일반적인 방식도 user-item matrix를 생성하긴 합니다.</em></p>

<p>일반적인 방식은 아이템이 많고 서비스 자체에서 user 데이터를 확보한 상태에서 학습을 진행합니다. 하지만 저희의 서비스는 난잡하게 있는 repository 중 awesome에서 선정한 repository를 위주로 선정했기 때문에 random user의 아이템 hit ratio가 굉장히 낮아질 위험이 있었습니다. 최악의 경우 user-item matrix의 모든 값이 0일 수도 있다는 것입니다. 이를 방지하고자 반드시 최소 1개는 hit가 되는 user-item matrix를 구축하기 위해 갖고 있는 repository에서 역으로 user를 추출하는 방식을 사용하기로 했습니다.<br />
저희가 hit를 하는 기준은 <strong>repository star</strong>이므로 repository의 star user list를 가져와서 학습용 user군을 확보하기로 했습니다. 각 repository별로 최대 100명씩 확보하기로 했고 최종적으로 중복된 유저를 제외하고 약 35만명의 user군이 확보될 것으로 확인했습니다.</p>

<h3 id="user-producer--repository-정보-update">User producer &amp; Repository 정보 update</h3>

<p>위의 방법을 사용하기 위해 아래 사진과 같은 방식으로 데이터를 수집하게 설계했습니다.</p>

<p><img src="/image/boostcamp/project/user_prod.png" alt="" w="500" /></p>

<p>여전히 Github oAuth token이 4개라는 제한이 있기 때문에 안정적인 수집을 위해서는 이전에 사용한 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>로 API request를 병렬처리하기에 약간의 리스크가 있었습니다. 따라서 기존 repository에 저장한 <code class="language-plaintext highlighter-rouge">star_pages</code>  필드를 활용해서 <code class="language-plaintext highlighter-rouge">star_pages</code>를 10으로 제한하고 각 페이지당 100명으로 값을 가져오게 했습니다.</p>

<p>API 호출의 효율성을 높이고 user-item matrix를 만들기 위해 필요한 repository star user list를 확보하고자 동시에 <code class="language-plaintext highlighter-rouge">update</code> 정보를 consumer로 같이 보내줘야 했습니다. 따라서 producer는 consumer에게 다음과 같은 방식으로 데이터를 전송하게 설정했습니다.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="p">{</span><span class="w">
    </span><span class="nl">"insert"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"uid"</span><span class="p">:</span><span class="w"> </span><span class="err">user</span><span class="w"> </span><span class="err">unique</span><span class="w"> </span><span class="err">id</span><span class="p">,</span><span class="w">
        </span><span class="nl">"login"</span><span class="p">:</span><span class="w"> </span><span class="err">user</span><span class="w"> </span><span class="err">github</span><span class="w"> </span><span class="err">id</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"update"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"rid"</span><span class="p">:</span><span class="w"> </span><span class="err">repository</span><span class="w"> </span><span class="err">unique</span><span class="w"> </span><span class="err">id</span><span class="p">,</span><span class="w">
        </span><span class="nl">"uid"</span><span class="p">:</span><span class="w"> </span><span class="err">star</span><span class="w"> </span><span class="err">user</span><span class="w"> </span><span class="err">id</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>이렇게 보내면 consumer는 데이터의 조건 분기로 update 정보와 insert 정보를 동시에 처리할 수 있다는 장점이 있고 consumer의 확장성이 늘어날 수 있습니다.</p>

<h3 id="consumer-설계-변경">Consumer 설계 변경</h3>

<p>기존의 consumer는 단순 insert만 처리하게 만들었습니다. insert 함수가 사용자가 설정한 주기에 맞춰 수행되어 batch 단위로 DB에 저장되는 방식이었습니다. 이 consumer의 문제점은 update가 발생할 경우 처리하기 어렵다는 문제가 있었습니다. 따라서 update 정보에 대한 확장이 필요했습니다.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="c1"># 기존의 consumer 데이터 처리 부분
</span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">schedule</span><span class="p">.</span><span class="n">run_pending</span><span class="p">()</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">isBlocking</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="n">loads</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">print</span><span class="p">()</span>

            <span class="n">batch_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이를 해결하고자 producer에서 insert와 update를 구분해서 정보를 보내고 해당 정보의 유무에 따라 consumer는 데이터를 처리하게 됩니다.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="c1"># 수정된 consumer 데이터 처리 부분
</span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">schedule</span><span class="p">.</span><span class="n">run_pending</span><span class="p">()</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">isBlocking</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="n">loads</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="s">"insert"</span><span class="p">]</span>

            <span class="k">if</span> <span class="s">"update"</span> <span class="ow">in</span> <span class="n">msg</span><span class="p">:</span>
                <span class="n">update_data</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="s">"update"</span><span class="p">]</span>
                <span class="n">rid</span> <span class="o">=</span> <span class="n">update_data</span><span class="p">[</span><span class="s">"rid"</span><span class="p">]</span>
                <span class="n">uid</span> <span class="o">=</span> <span class="n">update_data</span><span class="p">[</span><span class="s">"uid"</span><span class="p">]</span>
                <span class="n">conn_repo</span><span class="p">.</span><span class="n">update_one</span><span class="p">({</span><span class="s">"rid"</span><span class="p">:</span> <span class="n">rid</span><span class="p">},</span> <span class="p">{</span><span class="s">"$push"</span><span class="p">:</span> <span class="p">{</span><span class="s">"star_user_list"</span><span class="p">:</span> <span class="n">uid</span><span class="p">}})</span>

            <span class="k">if</span> <span class="n">insert</span><span class="p">:</span>
                <span class="n">batch_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">insert</span><span class="p">)</span>

            <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">print</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>아직 수정할 부분들이 있습니다.</p>
<ul>
  <li>어차피 데이터는 insert와 update를 모두 갖고 있으므로 update 처리도 insert 처럼 dictionary의 비어있음 여부로 처리하는 것이 안정적</li>
  <li>update를 특정 데이터에 대해서 진행하는 것이 아닌 들어오는 데이터에 맞춰 알아서 처리하는 방식으로 확장성을 높이면 좋을 듯
    <ul>
      <li>condition을 json에 추가로 작성해도 좋을까?</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="cloud-storage-설정-및-연결-코드-개발">Cloud Storage 설정 및 연결 코드 개발</h2>

<p>모델의 성능을 저장하고 보존하기 위해 <code class="language-plaintext highlighter-rouge">model.pt</code> 파일 정보를 저장할 필요가 있었습니다. 빠른 inference와 동시에 높은 성능을 확보하려면 batch 단위로 학습이 진행되는 기록들을 저장하고 inference에서는 높은 성능의 모델만 가져오면 되는 것입니다.<br />
이를 해결하고자 다음과 같은 두가지 방식을 고안했습니다.</p>

<ol>
  <li>MongoDB에 <code class="language-plaintext highlighter-rouge">model.pt</code>의 값을 dictionary로 저장</li>
  <li>GCP의 Cloud Storage에 저장하고 load하는 방식</li>
</ol>

<p>이때, 1번 과정은 시도를 해봤을 때, <code class="language-plaintext highlighter-rouge">model.pt</code> 내부의 n차원 <code class="language-plaintext highlighter-rouge">torch.tensor</code> 를 dictionary로 변경하는 과정에서 문제가 발생하였고 2번 방식을 사용하기로 채택했습니다.</p>

<h3 id="cloud-storage-설정">Cloud Storage 설정</h3>

<p>Cloud Storage 설정 자체는 어렵지 않았습니다. 블로그를 참고하여 설정했고 이를 사용하는 코드를 데이터 사이언티스트 분들이 원활하게 사용하는 코드를 개발하는 것에 좀 더 집중했습니다.</p>

<h3 id="저장-및-로드-코드-개발">저장 및 로드 코드 개발</h3>

<p>google cloud에서 제공하는 <code class="language-plaintext highlighter-rouge">google-cloud-storage</code> 라이브러리를 사용하면 원활하게 저장과 로드가 가능합니다. 하지만 사용과정에서 문제가 발생하는 것을 막고 MongoDB와의 저장, 로드도 병행해야하므로 코드를 atomic하게 작성할 필요가 있었습니다.<br />
따라서 <code class="language-plaintext highlighter-rouge">file_to_storage</code> 함수와 <code class="language-plaintext highlighter-rouge">download_file</code> 함수를 만들어서 팀원들과 공유했습니다.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">pymongo</span> <span class="kn">import</span> <span class="n">MongoClient</span>
<span class="kn">from</span> <span class="nn">google.cloud</span> <span class="kn">import</span> <span class="n">storage</span>
<span class="kn">import</span> <span class="nn">tarfile</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="k">def</span> <span class="nf">file_to_storage</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s">""</span><span class="p">,</span> <span class="n">db_conn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tar_zip</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">file_name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="n">file_path</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">"/"</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">tar_zip</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">tar_name</span> <span class="o">=</span> <span class="n">file_name</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">"."</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s">".tar"</span>
        <span class="k">with</span> <span class="n">tarfile</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">"."</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s">".tar"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="n">tar_name</span>

    <span class="n">storage_client</span> <span class="o">=</span> <span class="n">storage</span><span class="p">.</span><span class="n">Client</span><span class="p">()</span>
    <span class="n">bucket</span> <span class="o">=</span> <span class="n">storage_client</span><span class="p">.</span><span class="n">bucket</span><span class="p">(</span><span class="s">"model-save"</span><span class="p">)</span>
    <span class="n">blob</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="n">blob</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="n">blob</span><span class="p">.</span><span class="n">upload_from_filename</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">db_conn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">db_conn</span><span class="p">.</span><span class="n">insert_one</span><span class="p">({</span>
            <span class="s">"name"</span><span class="p">:</span> <span class="n">model_name</span><span class="p">,</span>
            <span class="s">"bucket_name"</span><span class="p">:</span> <span class="s">"model-save"</span><span class="p">,</span>
            <span class="s">"file_name"</span><span class="p">:</span> <span class="n">file_name</span><span class="p">,</span>
            <span class="s">"time"</span><span class="p">:</span> <span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">(),</span>
            <span class="s">"score"</span><span class="p">:</span> <span class="n">score</span><span class="p">,</span>
            <span class="s">"tag"</span><span class="p">:</span> <span class="n">tag</span>
        <span class="p">})</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"model save complete!"</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">file_to_storage</code> 함수의 기본 로직</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">file_name</code>을 지정하지 않으면 원본 파일명으로 저장</li>
  <li>tar 압축을 요청하는 영우 tar 파일로 압축</li>
  <li>cloud storage 연결, bucket, blob 세팅</li>
  <li>cloud storage에 파일 업로드</li>
  <li>저장한 model의 이름과 태그, 버킷명, 저장 파일 이름등 모델의 메타데이터를 MongoDB에 저장</li>
</ol>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">download_file</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">db_conn</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s">""</span><span class="p">,</span> <span class="n">latest</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">latest</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">db_conn</span><span class="p">.</span><span class="n">find</span><span class="p">({</span><span class="s">"name"</span><span class="p">:</span> <span class="n">model_name</span><span class="p">,</span> <span class="s">"tag"</span><span class="p">:</span><span class="n">tag</span><span class="p">}).</span><span class="n">sort</span><span class="p">(</span><span class="s">"time"</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">db_conn</span><span class="p">.</span><span class="n">find_one</span><span class="p">({</span><span class="s">"name"</span><span class="p">:</span><span class="n">model_name</span><span class="p">,</span> <span class="s">"tag"</span><span class="p">:</span><span class="n">tag</span><span class="p">}))[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">source_blob_name</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s">"file_name"</span><span class="p">]</span>
    <span class="n">storage_client</span> <span class="o">=</span> <span class="n">storage</span><span class="p">.</span><span class="n">Client</span><span class="p">()</span>
    <span class="n">bucket</span> <span class="o">=</span> <span class="n">storage_client</span><span class="p">.</span><span class="n">bucket</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="s">"bucket_name"</span><span class="p">])</span>
    <span class="n">blob</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="n">blob</span><span class="p">(</span><span class="n">source_blob_name</span><span class="p">)</span>
    
    <span class="n">blob</span><span class="p">.</span><span class="n">download_to_filename</span><span class="p">(</span><span class="n">source_blob_name</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"file download complete: </span><span class="si">{</span><span class="n">source_blob_name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">download_file</code> 함수의 기본 로직</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">model_name</code>과 <code class="language-plaintext highlighter-rouge">tag</code>를 활용해서 MongoDB에 저장된 내용을 탐색
    <ol>
      <li>이때, <code class="language-plaintext highlighter-rouge">tag</code>는 설정하지 않으면 자동적으로 공백 탐색</li>
    </ol>
  </li>
  <li>이후 cloud storage dusruf, bucket, blob 세팅</li>
  <li>파일 다운로드</li>
</ol>

<hr />

<h2 id="보완할-점">보완할 점</h2>

<p>이번 개발 일지에서 보완할 점은 다음과 같습니다.</p>
<ul>
  <li>좀 더 확장성 높은 consumer 개발</li>
  <li>tar 파일 압축했는데 사이즈가 그대로,….???</li>
  <li>지난번 redis producer-consumer에서 발생하는 문제로 너무 빠른 속도로 데이터가 전달되는 경우 데이터 유실이 발생하는 것으로 보이는데, 이게 진짜 유실인지 아니면 저장 과정에서 시간차가 있는건지 확인해 볼 필요가 있음</li>
</ul>

<hr />

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://soundprovider.tistory.com/entry/GCP-Python에서-GCP-Cloud-Storage-연동하기">[GCP] Python에서 GCP Cloud Storage 연동하기</a></li>
</ul>]]></content><author><name></name></author><category term="NAVER BoostCamp AI Tech" /><category term="Level 3 - Final Project" /><category term="NAVER" /><category term="BoostCamp" /><category term="AI Tech" /><category term="Proeject" /><category term="Data Engineering" /><category term="MLOps" /><category term="Redis" /><summary type="html"><![CDATA[Final Project : User 수집, Cloud storage]]></summary></entry><entry><title type="html">[BoostCamp AI Tech / Final] Day85 - Redis Producer Consumer</title><link href="https://cow-coding.github.io/posts/final5/" rel="alternate" type="text/html" title="[BoostCamp AI Tech / Final] Day85 - Redis Producer Consumer" /><published>2022-05-24T01:00:00+09:00</published><updated>2022-05-24T01:00:00+09:00</updated><id>https://cow-coding.github.io/posts/final5</id><content type="html" xml:base="https://cow-coding.github.io/posts/final5/"><![CDATA[<h1 id="final-project--redis-producer-consumer">Final Project : Redis Producer Consumer</h1>

<hr />

<h2 id="목차">목차</h2>

<ul>
  <li>Redis Producer Consumer</li>
  <li>데이터 수집 파이프라인 설계</li>
</ul>

<hr />

<h2 id="redis-producer-consumer">Redis Producer Consumer</h2>

<p>지난번에 이어서 구동시킨 redis server를 통해 message queue 방식을 활용해서 producer-consumer로 데이터를 DB에 적재시키는 파이프라인을 설계 했습니다.</p>

<p>급하게 파이프라인을 설계하고 데이터를 지속적으로 넣어줘야 하는 상황이라 data 수집 부분과 데이터베이스 삽입 부분을 분리해야 했습니다.</p>

<p><img src="/image/boostcamp/project/message_passing.png" alt="" /></p>

<p>이를 위해서는 OS에서 배웠던 message passing을 사용하면 처리할 수 있는 문제였습니다. message passing은 sender와 receiver가 메일박스를 통해 메시지를 전달하는 방식입니다. 여기서 message queue의 역할은 메시지 브로커인 redis server가 맡게되고 sender와 receiver는 구동되고 있는 redis server를 통해 데이터 전달을 합니다.</p>

<p>여기서 일반적으로 Sender를 Producer, Receiver를 Consumer로 말하기도 합니다.<br />
Consumer는 계속해서 데이터를 받으면서 프로그래머가 설정한 DB로 데이터를 넣습니다.<br />
결국 Producer 코드만 수정해서 producer는 데이터를 계속해서 넣어주면 됩니다.</p>

<hr />

<h2 id="데이터-수집-파이프라인-설계">데이터 수집 파이프라인 설계</h2>

<p><img src="/image/boostcamp/project/pipe_line_architecture.png" alt="" /></p>

<p>MSA로 설계한 파이프 라인입니다. 기본적으로 Producer는 문제가 발생해도 Consumer는 계속 msessage queue에서 데이터를 받아오게 됩니다. 설계의 장점은 다음과 같습니다.</p>
<ul>
  <li>지속적으로 데이터를 처리해준다는 것</li>
  <li>Consumer는 인자로 저장 collection을 바꿔주기 때문에 저장 확장성이 높다는 것입니다.</li>
  <li>Producer도 데이터에 맞춰서 모든 데이터 루틴을 다 수집하면 프로그램을 종료합니다. 따라서 마치 블록 조각을 조립하듯이 producer만 갈아 끼우면 데이터 수집을 다양하게 할 수 있다는 것입니다.</li>
</ul>

<h3 id="보완할-점">보완할 점</h3>

<p>설계에서 보완할 점으로는 다음과 같습니다.</p>
<ul>
  <li>Consumer의 중복 문제가 발생할 수도 있다는 점
    <ul>
      <li>Consumer를 순차적으로 처리할 방법을 찾아볼 필요가 있음</li>
    </ul>
  </li>
  <li>여러 docker를 사용하므로 kubernetes를 활용하면 더 좋을 것 (공부하자)</li>
  <li>Producer의 병렬화를 하는 방법을 구상해 볼 필요</li>
  <li>단순히 메시지 브로커보다는 활용도를 높이게 이벤트 브로커를 사용하는 것이 좋을 것 같음
    <ul>
      <li>Kafka를 써본다면 다양하게 활용할 수 있을 것으로 보임 (공부하자…2)</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://m.blog.naver.com/wideeyed/221370229153">[Python] Redis를 이용한 Message Queue 만들기</a></li>
</ul>]]></content><author><name></name></author><category term="NAVER BoostCamp AI Tech" /><category term="Level 3 - Final Project" /><category term="NAVER" /><category term="BoostCamp" /><category term="AI Tech" /><category term="Proeject" /><category term="Data Engineering" /><category term="MLOps" /><category term="Redis" /><summary type="html"><![CDATA[Final Project : Redis Producer Consumer]]></summary></entry><entry><title type="html">[BoostCamp AI Tech / Final] Day83 - GCP Redis 환경 세팅</title><link href="https://cow-coding.github.io/posts/final4/" rel="alternate" type="text/html" title="[BoostCamp AI Tech / Final] Day83 - GCP Redis 환경 세팅" /><published>2022-05-21T01:00:00+09:00</published><updated>2022-05-24T03:02:56+09:00</updated><id>https://cow-coding.github.io/posts/final4</id><content type="html" xml:base="https://cow-coding.github.io/posts/final4/"><![CDATA[<h1 id="final-project--gcp-redis-환경-세팅">Final Project : GCP Redis 환경 세팅</h1>

<hr />

<h2 id="목차">목차</h2>

<ul>
  <li>Redis 세팅 배경</li>
  <li>GCP Docker 설치</li>
  <li>Docker Redis</li>
  <li>Python redis 연결</li>
</ul>

<hr />

<h2 id="redis-세팅-배경">Redis 세팅 배경</h2>

<ul>
  <li>부캠 최종프로젝트에 사용하는 데이터를 수집하는데 여러가지 이슈가 발생</li>
  <li>이슈 내용
    <ul>
      <li>github api를 통해 선정한 repository별로 user 정보를 추출해야 함</li>
      <li>githup api는 oAuth token을 사용하면 5000/시간 호출 가능</li>
      <li>호출 수 초과하면 <code class="language-plaintext highlighter-rouge">HTTPError</code> 반환해서 데이터 수집이 중단됨</li>
      <li>중단점 발생시 데이터를 저장하고, 이후 중단점부터 다시 데이터를 수집</li>
    </ul>
  </li>
</ul>

<p><img src="/image/boostcamp/project/issue.png" alt="" w="550" /><em>도저히 메모리에 다 올려놓고 처리하는건 아무리 생각해도 머리가 안 돌아가서 슬랙에 도움을 요청했습니다.</em></p>

<ul>
  <li>부캠에 있는 고수분께서 해결책을 제시
    <ul>
      <li>message 브로커를 활용해서 메시지 큐 내부에 저장해두고</li>
      <li>worker가 메시지 브로커의 정보를 주기적으로 DB에 저장하는 방법을 추천</li>
    </ul>
  </li>
  <li>message 브로커는 redis를 활용하신다고 하셨음</li>
  <li>pub/sub 환경을 사용하고자 nats를 사용하심</li>
</ul>

<p>일단 구세주분께서 자세히 알려주셔서 알려주신 방법을 차근차근 따라가보기로 했습니다. 추가적으로 변성윤 마스터님께서도 해결책을 제시해주셨습니다. 해당 해결책은 글 마지막에 추가로 작성하겠습니다.</p>

<hr />

<h2 id="gcp-docker-설치">GCP Docker 설치</h2>

<ul>
  <li>우선 redis를 계속해서 돌리는 환경을 만들어야 함</li>
  <li>backgroung보다는 docker로 계속 돌리는 것이 안정적이라 판단</li>
  <li>GCP에 docker부터 설치</li>
  <li>Docker <a href="https://docs.docker.com/engine/install/ubuntu/">공식문서</a>를 확인해서 잘 설치하면 됨</li>
</ul>

<hr />

<h2 id="docker-redis">Docker Redis</h2>

<ul>
  <li>docker로 redis server를 background 형태로 돌려야 함</li>
  <li>redis image의 기본 port는 6379이므로 GCP의 6379 port forwarding을 진행</li>
  <li>docker가 GCP VM에 올라가서 동작하므로 <strong>반드시 네트워크의 모든 인스턴스</strong>를 대상으로 연결해줘야 함
    <ul>
      <li>방화벽 규칙 설정시 대상 태그를 아무렇게나 지으면 안됨</li>
      <li>반드시 일치하는 대상을 선정해야 외부 연결에 문제가 없음</li>
      <li>이거 때문에 2시간을 고생… ㅠㅠ</li>
    </ul>
  </li>
</ul>

<p><img src="/image/boostcamp/project/port.png" alt="" /><em>정확히 맞는지 모르겠지만 localhost의 6379 포트를 안 열면 에러가 났던걸로 기억한다.</em></p>

<p>포트 포워딩까지 했으니까 이제 GCP에서 redis를 background로 docker 실행해서 계속 동작하게 만들고 외부에서 python을 통해 송수신이 가능한지 확인하겠습니다.</p>

<h3 id="redis-docker-실행">Redis docker 실행</h3>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>docker pull redis
<span class="nv">$ </span>docker run <span class="nt">--name</span> myredis <span class="nt">-d</span> <span class="nt">-p</span> 6379:6379 redis
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>docker로 redis 실행은 <a href="http://redisgate.kr/redis/education/docker_intro.php">redisgate</a>문서 참고해서 설정</li>
</ul>

<p><img src="/image/boostcamp/project/docker_redis.png" alt="" /></p>

<hr />

<h2 id="python-redis-연결">Python redis 연결</h2>

<ul>
  <li>python에서 redis를 연결하는 방법으로는 <a href="https://github.com/redis/redis-py">redis-py</a>를 사용</li>
  <li>redis-py 사용해서 이제 GCP 상의 redis server와 연결되는지 확인
    <ul>
      <li>여기서 <strong>포트 포워딩시 대상 지정 잘못하면 연결 안되고 timeout</strong></li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">redis</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">Redis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">"your_host"</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">decode_responses</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">r</span><span class="p">.</span><span class="n">ping</span><span class="p">()</span>    <span class="c1"># True
</span></pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>redis 연결시 확인할 것이 몇가지 있음
    <ul>
      <li>host는 GCP의 docker를 쓰므로 GCP 외부연결 IP를 사용하면 됨</li>
      <li><code class="language-plaintext highlighter-rouge">decode_responses</code>를 <code class="language-plaintext highlighter-rouge">True</code>로 안하면 redis는 binary 형태로 데이터를 저장하므로 <code class="language-plaintext highlighter-rouge">.get</code>계열로 값을 가져오면 모두 <strong>binary</strong> 데이터양식
        <ul>
          <li>원본 데이터 형태로 <code class="language-plaintext highlighter-rouge">get</code>하려면 반드시 <code class="language-plaintext highlighter-rouge">decode_responses</code>를 <code class="language-plaintext highlighter-rouge">True</code>로 설정해야 함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>dictionary를 설정할 때
    <ul>
      <li><code class="language-plaintext highlighter-rouge">r.hmset("key", dictionary_val)</code>로 작성하면 됨</li>
      <li><code class="language-plaintext highlighter-rouge">r.hgetall("key")</code> 사용하면 해당 value 모두 가져올 수 있음</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="변성윤-마스터님-피드백">변성윤 마스터님 피드백</h2>

<ul>
  <li>단순하게 API 호출 제한의 문제가 있다면
    <ul>
      <li>API 호출을 우회할 수 있는 방법이 있는지(Key를 더 생성할 수 있을지, 혹시 Key가 없다면 User Agent를 추가하거나 요청하는 IP를 변경해서 처리할 수 있을지)를 고민해볼 것 같아요</li>
    </ul>
  </li>
  <li>또 다른 문제로 중간에 “진행하는 과정까지 된 부분만 반영하고 싶다”
    <ul>
      <li>이 부분은 Database의 Commit이란 개념을 아시면 더욱 도움이 될 것 같아요</li>
      <li>Database를 수업 시간에 다루진 않았지만, 꼭 보시면 좋을 개념이라 따로 공부해보셔요</li>
      <li>Database에선 Transaction이 발생하는데, 그 과정에서 commit이란 과정이 존재합니다.</li>
      <li>Commit이 트랜잭션의 종료를 의미하고, 만약 작업 중 문제가 생기면 Rollback이 진행됩니다</li>
      <li>기범님의 코드에서 토큰 이슈로 호출이 안되는 에러가 발생하면, 그 전까지의 기록(배열에 담고있다거나)를 바로 데이터베이스로 넘기면 되는 것이지요</li>
      <li>그리고 작업이 시작될 때는 데이터베이스의 id를 가지고 가서 작업하면 됩니다</li>
      <li>Database의 개념적인 부분을 활용해 구현하는 케이스라고 보셔도 될 것 같아요</li>
      <li><a href="https://wikidocs.net/4096">https://wikidocs.net/4096</a></li>
    </ul>
  </li>
  <li>혹은 동훈님이 하신 것처럼 메세지 시스템에 던지는 역할과 뒤에서 담는 역할을 나누는 것도 방법입니다
    <ul>
      <li>Redis 외에 클라우드 서비스엔 AWS SQS도 있는데 트래픽의 증가에 따라 자동으로 트래픽 대응하도록 할 수도 있습니다!</li>
    </ul>
  </li>
  <li>Table의 Key를 잘 만드셔서, 혹시 중복이 들어가더라도 이슈가 없도록 만드는 것도 중요합니다</li>
</ul>

<p>구체적인 부분은 디테일한 상황에 따라 다를 것 같은데, 저는 토큰을 갱신하지 못한다고 하면.. Selenium을 병렬로 띄워서 크롤링하는 것도 생각했습니다(셀레니움이 느리긴 하지만 수집 못하는 것은 없으니 병렬로 진행했어요)
병렬로 진행하는 과정에서 저는 Ray라는 라이브러리를 주로 사용하고 있습니다. 라이브러리가 약간 불안정하긴 하지만, 간단하게 쓰기엔 괜찮아서 Ray를 사용하고 있어요. 회사에선 순간 엄청 많은 연산량이 필요해서 CPU 224 Core를 선점형 인스턴스(저렴한 인스턴스)에 Ray로 병렬처리해서 10분만에 끝내기! 등을 했던 기억이 있네요</p>]]></content><author><name></name></author><category term="NAVER BoostCamp AI Tech" /><category term="Level 3 - Final Project" /><category term="NAVER" /><category term="BoostCamp" /><category term="AI Tech" /><category term="Proeject" /><category term="Data Engineering" /><category term="MLOps" /><summary type="html"><![CDATA[Final Project : GCP Redis 환경 세팅]]></summary></entry></feed>