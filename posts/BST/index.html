<!DOCTYPE html><html lang="en" data-mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="[Data Structure] Binary Search Tree (이진 탐색 트리)" /><meta property="og:locale" content="en" /><meta name="description" content="A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation." /><meta property="og:description" content="A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation." /><link rel="canonical" href="https://cow-coding.github.io/posts/BST/" /><meta property="og:url" content="https://cow-coding.github.io/posts/BST/" /><meta property="og:site_name" content="Coding Gallery" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-21T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Data Structure] Binary Search Tree (이진 탐색 트리)" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="TXb5nWUV5Ag0O8EVGMTUS11ZVi7BYOensPMiRdQGNRg" /> <script type="application/ld+json"> {"description":"A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.","url":"https://cow-coding.github.io/posts/BST/","@type":"BlogPosting","headline":"[Data Structure] Binary Search Tree (이진 탐색 트리)","dateModified":"2022-01-14T02:41:57+09:00","datePublished":"2020-07-21T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://cow-coding.github.io/posts/BST/"},"@context":"https://schema.org"}</script><title>[Data Structure] Binary Search Tree (이진 탐색 트리) | Coding Gallery</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Coding Gallery"><meta name="application-name" content="Coding Gallery"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4761810170892865" crossorigin="anonymous"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/my_img/icebear.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Coding Gallery</a></div><div class="site-subtitle font-italic">마침표를 찍고 조금 더 멀리</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/cow-coding" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['kbp0237','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Data Structure] Binary Search Tree (이진 탐색 트리)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Data Structure] Binary Search Tree (이진 탐색 트리)</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/cow-coding">Park Kibum</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2020-07-21 00:00:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Tue, Jul 21, 2020, 12:00 AM +0900" >Jul 21, 2020</em> </span> <span> Updated <em class="timeago" date="2022-01-14 02:41:57 +0900 " data-toggle="tooltip" data-placement="bottom" title="Fri, Jan 14, 2022, 2:41 AM +0900" >Jan 14, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3759 words"> <em>20 min</em> read</span></div></div></div><div class="post-content"><style> img { width:400px; display:block; margin:0px auto; }</style><h1 id="binary-search-tree-이진-탐색-트리">Binary Search Tree (이진 탐색 트리)</h1><p>이진 탐색 트리는 앞서서 배운 트리의 확장적인 형태라고 보면 편하다. 일반적인 이진 트리는 탐색의 기준이 없어서 특정 데이터를 찾으려면 모든 노드를 탐색해야한다.<br /> 하지만 이진 탐색 트리에서는 평균적으로 훨씬 빠른 시간에 탐색이 가능해진다.</p><h2 id="binary-search-이진-탐색">Binary Search (이진 탐색) <a href="#binary-search-이진-탐색" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>우선 이진 탐색과 이진 탐색 트리를 구분해야 한다. 전자는 알고리즘의 일종이고 후자는 자료구조의 일종이다. 이진 탐색 트리의 원리를 알기 이전에 이진탐색의 원리를 알아야 한다.<br /> 이진 탐색은 간단하게 말하면 탐색 범위를 절반으로 줄여나가는 탐색이다. 바로 <a href="https://cow-coding.github.io/data%20structure/2020/07/15/DS10/#">이전 포스트</a>에서 말한 search table과 같다. 굳이 자세한 설명을 더 하진 않겠다.<br /> 이런 이진 탐색을 트리 형태로 구조화시키면 그게 이진 탐색 트리이다.</p><h2 id="시간-복잡도">시간 복잡도 <a href="#시간-복잡도" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>BST의 시간복잡도는 트리의 모양과 관련이 깊다. 기준값보다 큰 값을 우측으로, 작은 값을 좌측으로 보내기 때문에 특정 데이터 셋에서는 트리가 한쪽으로 일렬 형태의 트리가 나올 수도 있다. 시간복잡도는 일반적으로 $ O(h)$ 로 나타내는데, 이렇게 극단적인 경우에서의 시간복잡도는 $ O(n)$ 의 시간복잡도를 갖는다. 모든 데이터를 통과해야지 삽입, 삭제가 가능하기 때문이다.<br /> 반면에 좌우 균형이 알맞은 이진 트리는 h가 $ \log{n}$ 을 띄므로 $ O(\log{n})$ 의 시간복잡도를 갖는다.</p><h2 id="deletion-case-삭제-케이스">Deletion case (삭제 케이스) <a href="#deletion-case-삭제-케이스" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>이진 탐색 트리의 삭제 과정은 삭제하는 노드의 조건에 따라 삭제 방식이 바뀌게 된다. 크게 2가지 경우의 케이스로 분류된다.</p><ol><li>삭제할 노드의 자식 중 하나라도 리프 노드일 때<li>삭제할 노드의 자식이 모두 존재할 때</ol><p>1번 경우는 처리해주는 것이 어렵지 않다. 삭제노드를 지우고 그 아래 있는 자식을 바로 연결해주면 된다. 문제는 2번 케이스에서 발생된다. 생각보다 해줘야 하는 작업이 많기 때문이다.<br /> 2번 케이스가 1번 케이스와 다르게 문제가 발생하는 이유는 간단한데, 1번 케이스는 자신 밑에 자식이 있거나 없기 때문에 자신의 데이터가 후속 데이터에 크게 영향이 미치지 않는다. 하지만 자식이 둘이라는 의미는 후속 데이터가 영향을 받을 수 있다.<br /> 자식이 둘인 경우 후속 데이터가 영향을 받는다는 게 무슨 의미냐면 아래와 같다고 생각하면 된다.</p><p><img data-src="/image/DS/bst_del.png" alt="bst" data-proofer-ignore><br /> 위의 상황처럼 3번 노드를 제거하는 상황이면 단순하게 3번을 제거하고 2번이나 8번을 해당 위치에 대체하면 문제가 발생한다. 8번이 해당 위치를 대체한다면 6번 아래에 있는 모든 노드들은 2번 자식들로 모두 옮겨져야 한다는 문제가 발생한다. 2번을 대체한다고 해도 지금은 문제가 없어 보이지만 2번 아래에 자식이 있다면 똑같은 문제가 발생한다.<br /> 그래서 일반적으로 삭제하는 노드들 대체하는 노드는 삭제 노드의 오른쪽 트리 중 가장 작은 값으로 대체한다. <br /> 오른쪽 부분 트리의 가장 왼쪽 리프 노드는 이진 탐색 트리의 원리상 삭제 노드와 가장 가까우면서 큰 노드가 되게 된다.</p><h1 id="avl-tree-균형-잡힌-이진-탐색-트리">AVL-Tree (균형 잡힌 이진 탐색 트리)</h1><p>앞서서 말한 시간복잡도 부분에서 완벽하게 $ O(\log{n})$ 을 보장하지 못함을 알 수 있다. 이러한 것을 보장하기 위해서 나온 것이 AVL Tree이다. AVL 트리는 항상 양쪽 균형이 최대한 맞춰진 이진 탐색 트리이다. <del>(참고로 AVL은 사람이름이다.)</del><br /> 이전에 트리에서 노드의 높이를 말한 적이 있는데, 노드의 높이면 해당 노드를 루트 노드로 하는 부분 트리라고 했다. AVL Tree는 자식 노드의 높이차이가 최대 1까지만 나는 경우를 말한다.</p><p><img data-src="/image/DS/avltree.png" alt="avl" data-proofer-ignore><br /> 부분 트리의 높이를 계산할 때 아래서부터 카운트를 하는데, 리프노드가 1인 이유는 일반적으로 리프노드에 2개의 더미노드가 존재하기 때문이다. 더미노드의 높이를 0이라고 간주한다. 부모노드의 높이는 자식 노드 중 높은 것의 높이 +1을 한 값이 된다. AVL 트리의 이런 성질 height-balance property라고 한다. AVL Tree는 새로운 값이 삽입되거나 삭제되었을 때, height-balance property를 유지를 해야 한다. 그래서 그런 높이를 조정하는 과정이 Trinode Restructuring 또는 Rotation이라고 한다.</p><h2 id="rotation-회전">Rotation (회전) <a href="#rotation-회전" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>회전은 AVL Tree의 각 부분트리들의 높이를 조정해주는 과정에서 사용된다. 회전은 보통 1번이나 2번으로 이루어지고 왼쪽 회전, 오른쪽 회전이라고 부른다. 이런 회전의 조합이 1번이냐 2번이냐에 따라 1번 회전, 2번 회전으로 구분된다.<br /> 위의 트리에서 삽입이 이루어진 경우를 한 번 보자.</p><p><img data-src="/image/DS/avlinsert1.png" alt="avl insert1" data-proofer-ignore><br /> 54를 가진 노드가 추가되면서 78 값을 가진 노드에서 높이 밸런스 특성이 깨졌다. 설명의 편의를 위해서 노드의 값을 노드의 이름으로 부르겠다. 78노드의 높이가 4인 이유는 자식의 높이 중 가장 큰 높이+1이 부모의 높이가 되기 때문이다.<br /> AVL Tree는 height-balance property를 유지해야 하므로 회전을 진행한다. 회전을 진행하는 과정에서는 총 3개의 노드가 위치를 바꾸게 되는데, 3개의 노드는 x,y,z라고 지칭한다. 그리고 해당 노드를 정하는 조건은 다음과 같다.</p><ol><li>z노드는 최초로 height-balance가 깨진 노드로 한다. (78노드)<li>y노드는 z노드의 자식 중 가장 높이가 높은 노드이다. (50노드)<li>x노드는 y노드 중 가장 높이가 높은 노드이다. (62노드)<li>2,3번 과정에서 자식 노드들의 높이가 같으면 보통 왼쪽 노드를 선택한다. 회전의 편의성을 위해서이다.</ol><p>이렇게 정해진 x, y, z노드에 다시 a, b, c라는 이름을 붙여준다. a, b, c를 붙이는 조건은 중위순회를 기준으로 먼저 중위순회가 이뤄지는 순서로 이름을 붙여준다. 여기서는 y,x,z순서로 a,b,c가 붙여진다.</p><p><img data-src="/image/DS/avlinsert2.png" alt="avl insert2" data-proofer-ignore><br /> 이렇게 설정된 노드에서 x를 가운데로, y를 왼쪽, z를 오른쪽 자식으로 놓게 설정한다. 그 후에 자식을 크기 순서로 놓아주면된다. 이렇게 위치를 조정하면 아래와 같이 높이 밸런스가 알맞게 조정이 된다.</p><p><img data-src="/image/DS/avlinsertfinal.png" alt="avl insert final" data-proofer-ignore><br /> 실제로 이 과정은 이렇게 보면 단순하게 회전이 진행된 것 같지만 2번 회전한 경우에 해당된다. 일반적으로 1번 회전하는 경우는 a, b, c가 일렬로 연결이 된 경우에 해당된다. 위는 a, b, c가 지그재그 형태로 이뤄진 경우로 2번 회전을 진행하게된다. 간단한 회전의 경우를 보면 아래처럼 구분된다고 보면 된다.</p><p><img data-src="/image/DS/singlerotation.png" alt="single" data-proofer-ignore><br /> 위와 같은 경우는 1번 회전을 진행한 single rotation이라고 한다. 중심이 되는 노드가 b가 되게 만드려면 왼쪽으로 돌려야하므로 왼쪽 회전이라고 한다. 반대의 경우는 오른쪽 회전이라고 한다.</p><p><img data-src="/image/DS/doublerotation.png" alt="double" data-proofer-ignore> 이 경우가 예시로 들었던 2중 회전의 경우이다. 2중 회전은 사실 별 거라고 느낄 필요는 없다. 우선 b와 c를 교체해준다. 그러면 single rotation의 형태를 띄게되는데, 여기서는 일반적인 single rotation처럼 진행해주면 된다.<br /> 삭제가 발생했을 경우에도 삽입과 같이 높이들을 조정해주면 된다.<br /> <strong>여기서 주의해야할 점이 있는데, 삽입은 height balance가 깨진 노드를 조정해도 그 부모에 영향이 없다. 하지만 제거를 진행하면 height balance를 조정하더라도 부모 노드의 높이에 영향을 끼칠 수 있어서 루트노드까지 모든 hegith balance를 체크해주는 과정을 진행해야한다.</strong><br /> <del>사실 나도 AVL Tree는 너무 어렵다… 이론적으로 대충 이해만 하고 넘어가는 정도…</del></p><h1 id="bst-implementation-이진-탐색-트리-구현">BST implementation (이진 탐색 트리 구현)</h1><h2 id="node-prototype">Node prototype <a href="#node-prototype" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">parent</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="n">Node</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">child</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">degree</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">depth</span><span class="p">();</span>

  <span class="o">~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{}</span>

  <span class="k">friend</span> <span class="k">class</span> <span class="nc">BST</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>이진 트리에서 한 것처럼 이진 트리의 노드 클래스의 함수들이다. 생성자는 일반적인 이진 트리의 생성자와 동일하다. 여기서 노드의 부모자식 관계를 처리하는 함수인 insert와 트리의 깊이와 자식 수를 반환해주는 함수를 만들었다.</p><h3 id="node-insert-function">Node insert function <a href="#node-insert-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
    <span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
    <span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>
</pre></table></code></div></div><p>노드의 자식을 결정해주는 함수이다. 자식으로 들어오는 노드의 값이 현재 노드보다 크면 오른쪽 자식으로 지정해주고 반대의 경우는 왼쪽 자식으로 지정해준다.</p><h3 id="node-degree-and-depth">Node degree and depth <a href="#node-degree-and-depth" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">degree</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">deg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">deg</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">deg</span><span class="o">++</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">deg</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">depth</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>degree는 간단하게 자식이 있는 경우를 보고 카운트를 올려주면 된다. depth가 좀 어려운데, 가장 좋은 방법은 재귀함수로 구현해주면 된다. 루트가 0이고 0에서부터 1씩 올려주면서 값을 반환해주면 된다.</p><h2 id="bst-prototype">BST prototype <a href="#bst-prototype" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Node</span> <span class="p">{...};</span>

<span class="k">class</span> <span class="nc">BST</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="n">BST</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">BST</span><span class="p">()</span> <span class="p">{</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">treeDestructor</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);}</span>

  <span class="kt">void</span> <span class="n">treeDestructor</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">temp</span><span class="p">);</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">findNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">findMin</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">delNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">transplant</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>트리이므로 소멸자를 확실히 진행해줘야한다. findMin과 findNode는 노드를 제거하는 경우에서 활용이 되므로 반드시 만들어줘야한다.</p><h3 id="tree-destructor-function">Tree destructor function <a href="#tree-destructor-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">treeDestructor</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">treeDestructor</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">treeDestructor</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>

  <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>트리를 제거하는 함수이다. 기본적인 원리는 dfs의 형식으로 가장 안쪽의 리프노드부터 제거해준다. 그렇게 제거해주면서 모든 노드를 제거한다.</p><h3 id="find-node-function">Find node function <a href="#find-node-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">Node</span><span class="o">*</span> <span class="nf">findNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">)</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>나름 가독성을 신경썼는데 별로 좋은거 같진 않다….<br /> 반복문의 이동은 현재 노드가 더미에 도달한 상황에서 종료시킨다. 리프가 더미에 도달했다는 의미는 찾고자하는 노드가 없다는 의미이므로 해당 노드가 없다는 의미로 NULL을 반환해준다. 찾는 노드를 찾았다면 해당 노드를 반환해주면된다.</p><h3 id="find-min-node-function">Find min node function <a href="#find-min-node-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">Node</span><span class="o">*</span> <span class="nf">findMin</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>주어진 노드를 루트로 하는 부분 트리의 최소 노드를 찾아낸다. 방법은 이진 탐색 트리 원리를 활용하면된다. 현재 루트부터 가장 왼쪽으로 계속 이동하면된다.</p><h3 id="insert-function">Insert function <a href="#insert-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
      <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">newNode</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>새로운 값을 삽입하는 함수이다. 들어갈 위치가 반드시 있으므로 들어갈 위치를 찾으면 반복을 멈춰준다. 반복이 종료된 이후에는 노드에 있는 삽입함수로 노드를 연결해주면된다.</p><h3 id="delete-and-transplant-function">Delete and transplant function <a href="#delete-and-transplant-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">transplant</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">u</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
    <span class="n">u</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">delNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">findNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">transplant</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
  <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">transplant</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
  <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">min</span> <span class="o">=</span> <span class="n">findMin</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">min</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">transplant</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">min</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
      <span class="n">min</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
      <span class="n">min</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">transplant</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">min</span><span class="p">);</span>
    <span class="n">min</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="n">min</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>transplant함수는 이름처럼 자식을 삭제노드의 부모에 이식하는 함수이다. if문과 else if문까지는 deletion case1에 해당하는 자식이 1개이거나 없는 경우에 시행된다.<br /> 가장 까다로운 부분이 else인 deletion case2에 해당된다. 우선 가장 작은 노드를 저장해주고 기존에 말했던 방식처럼 삭제를 진행해주면 된다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/datastructure/'>DataStructure</a>, <a href='/categories/c/'>C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/datastructure/" class="post-tag no-text-decoration" >DataStructure</a> <a href="/tags/dictionary/" class="post-tag no-text-decoration" >Dictionary</a> <a href="/tags/tree/" class="post-tag no-text-decoration" >Tree</a> <a href="/tags/binary-search-tree/" class="post-tag no-text-decoration" >Binary Search Tree</a> <a href="/tags/bst/" class="post-tag no-text-decoration" >BST</a> <a href="/tags/avl-tree/" class="post-tag no-text-decoration" >AVL Tree</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Data Structure] Binary Search Tree (이진 탐색 트리) - Coding Gallery&url=https://cow-coding.github.io/posts/BST/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Data Structure] Binary Search Tree (이진 탐색 트리) - Coding Gallery&u=https://cow-coding.github.io/posts/BST/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Data Structure] Binary Search Tree (이진 탐색 트리) - Coding Gallery&url=https://cow-coding.github.io/posts/BST/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/coursera2_3/">[MLOps Specialization / Step2] Labeling Data</a><li><a href="/posts/module/">[BoostCamp AI Tech / 심화포스팅] torch.nn.Module 뜯어먹기</a><li><a href="/posts/list/">[Deep Dive Python] 2. List</a><li><a href="/posts/variable/">[Deep Dive Python] 1. Python의 객체와 변수 개념</a><li><a href="/posts/final7/">[BoostCamp AI Tech / Final] Day91 - Airflow setting 및 배치 파이프라인 설계</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai-tech/">AI Tech</a> <a class="post-tag" href="/tags/boostcamp/">BoostCamp</a> <a class="post-tag" href="/tags/naver/">NAVER</a> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/mlops/">MLOps</a> <a class="post-tag" href="/tags/data-engineering/">Data Engineering</a> <a class="post-tag" href="/tags/project/">Project</a> <a class="post-tag" href="/tags/basic/">Basic</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/recommender-system/">Recommender System</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Tree/"><div class="card-body"> <em class="timeago small" date="2020-07-07 00:00:00 +0900" >Jul 7, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Data Structure] Tree (트리)</h3><div class="text-muted small"><p> Tree (트리) 트리 개념 트리는 non linear data structure이다. 앞서서 배운 리스트, 배열, 벡터는 모두 linear data structure이고 이런 선형 자료구조들은 원소들 간에 전/후 관계가 있다. 그러나 non linearr data structure, 즉 비선형 자료구조는 원소들 간에 상/하 관계를 가지고 있다. ...</p></div></div></a></div><div class="card"> <a href="/posts/BTree/"><div class="card-body"> <em class="timeago small" date="2020-07-08 00:00:00 +0900" >Jul 8, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Data Structure] Binary Tree (이진트리) & Tree 구현</h3><div class="text-muted small"><p> Binary Tree (이진 트리) 이진트리 개념 이진트리는 우리가 이전에 배운 트리의 특수한 형태이다. 일반 트리가 자식 수에 제한이 없다면, 이진트리는 1부모에 최대 2개의 자식 노드가 존재한다. 보통 왼쪽 노드, 오른쪽 노드라고 부르며 왼쪽 노드가 오른쪽 노드보다 우선하는 성질을 가진다. 일반 트리에서 설명하지 않았지만 트리는 자식간에 순서가...</p></div></div></a></div><div class="card"> <a href="/posts/Hash/"><div class="card-body"> <em class="timeago small" date="2020-07-15 00:00:00 +0900" >Jul 15, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Data Structure] Hash (해시)</h3><div class="text-muted small"><p> Dictionary (딕셔너리) 딕셔너리는 사실 C++보다는 파이썬에서 더 익숙할 것이라 생각된다. 실제로 딕셔너리라고 아예 명확하게 말을 하기도 하니까… 자료구조에서 딕셔너리는 key와 value를 함께 저장하는 entry 저장 자료구조이다. 대신 key의 중복을 허용한다. 시간 복잡도 딕셔너리의 시간복잡도는 딕셔너리를 리스트 구현을 기준으로 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Hash/" class="btn btn-outline-primary" prompt="Older"><p>[Data Structure] Hash (해시)</p></a> <a href="/posts/Graph/" class="btn btn-outline-primary" prompt="Newer"><p>[Data Structure] Graph (그래프)</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://cow-coding.github.io/posts/BST/'; this.page.identifier = '/posts/BST/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://cow-coding.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/cow-coding">Park Kibum</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai-tech/">AI Tech</a> <a class="post-tag" href="/tags/boostcamp/">BoostCamp</a> <a class="post-tag" href="/tags/naver/">NAVER</a> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/mlops/">MLOps</a> <a class="post-tag" href="/tags/data-engineering/">Data Engineering</a> <a class="post-tag" href="/tags/project/">Project</a> <a class="post-tag" href="/tags/basic/">Basic</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/recommender-system/">Recommender System</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { loader: {load: ['[tex]/color']}, chtml: { scale: 1.2 }, tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ], packages: {'[+]':['color']} } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-163727422-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-163727422-1'); }); </script>
