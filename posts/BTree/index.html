<!DOCTYPE html><html lang="en" data-mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="[Data Structure] Binary Tree (이진트리) &amp; Tree 구현" /><meta property="og:locale" content="en" /><meta name="description" content="A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation." /><meta property="og:description" content="A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation." /><link rel="canonical" href="https://cow-coding.github.io/posts/BTree/" /><meta property="og:url" content="https://cow-coding.github.io/posts/BTree/" /><meta property="og:site_name" content="Coding Gallery" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-08T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Data Structure] Binary Tree (이진트리) &amp; Tree 구현" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="TXb5nWUV5Ag0O8EVGMTUS11ZVi7BYOensPMiRdQGNRg" /> <script type="application/ld+json"> {"description":"A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.","url":"https://cow-coding.github.io/posts/BTree/","@type":"BlogPosting","headline":"[Data Structure] Binary Tree (이진트리) &amp; Tree 구현","dateModified":"2022-01-14T02:41:57+09:00","datePublished":"2020-07-08T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://cow-coding.github.io/posts/BTree/"},"@context":"https://schema.org"}</script><title>[Data Structure] Binary Tree (이진트리) & Tree 구현 | Coding Gallery</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Coding Gallery"><meta name="application-name" content="Coding Gallery"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4761810170892865" crossorigin="anonymous"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/my_img/icebear.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Coding Gallery</a></div><div class="site-subtitle font-italic">마침표를 찍고 조금 더 멀리</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/cow-coding" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['kbp0237','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Data Structure] Binary Tree (이진트리) & Tree 구현</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Data Structure] Binary Tree (이진트리) & Tree 구현</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/cow-coding">Park Kibum</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2020-07-08 00:00:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 8, 2020, 12:00 AM +0900" >Jul 8, 2020</em> </span> <span> Updated <em class="timeago" date="2022-01-14 02:41:57 +0900 " data-toggle="tooltip" data-placement="bottom" title="Fri, Jan 14, 2022, 2:41 AM +0900" >Jan 14, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3526 words"> <em>19 min</em> read</span></div></div></div><div class="post-content"><style> img { width:300px; display:block; margin:0px auto; }</style><h1 id="binary-tree-이진-트리">Binary Tree (이진 트리)</h1><h2 id="이진트리-개념">이진트리 개념 <a href="#이진트리-개념" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>이진트리는 우리가 이전에 배운 트리의 특수한 형태이다. 일반 트리가 자식 수에 제한이 없다면, 이진트리는 1부모에 최대 2개의 자식 노드가 존재한다.<br /> 보통 왼쪽 노드, 오른쪽 노드라고 부르며 왼쪽 노드가 오른쪽 노드보다 우선하는 성질을 가진다. 일반 트리에서 설명하지 않았지만 트리는 자식간에 순서가 있는 ordered pair이다.<br /> 이진트리의 쓰임새는 아래와 같은 것들이 있다.</p><ul><li>수식의 표현 트리<li>수식의 계산 트리<li>결정트리</ul><p>우선 결정트리부터 설명해보면 internal node는 결정요소를 갖고있고 external node는 해당 결정요소에대한 결정 값들을 갖고있다.<br /> 후에 서술할 중위순회를 이용하면 수식을 표현할 수 있다.</p><h2 id="완전-이진트리의-성질">완전 이진트리의 성질 <a href="#완전-이진트리의-성질" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>완전 이진트리는 이진트리에서의 모든 internal node의 자식이 2개로 꽉 차있는 상태의 이진트리를 말한다. 이런 이진트리에서는 특별한 수식적 성질들이 있다. 우선 설명을 하기 전에 간단한 기호의 규칙들을 정해보겠다.</p><ul><li>n : 노드의 개수<li>e : 리프 노드의 개수 (number of external nodes)<li>i : internal nodes의 개수<li>h : 높이</ul><p>위와 같이 정하고 완전 이진트리의 성질을 이야기해보자.</p><ol><li>$ e = i + 1$ 리프노드의 수는 내부노드 + 1이다. 왜 그럴까?<br /> 모든 노드는 2개의 자식을 갖고 있다. 그래서 만약 여기서만 internal node가 n개면 총 2n개의 자식이 존재한다. (어떤 부모는 다른 부모의 자식일 수 있다.)<br /> 이때, 모든 루트노드를 제외한 모든 노드는 부모를 갖고 있다. 결국 n-1개의 노드가 부모를 갖고 있다.<br /> 그 뜻은 다른 말로 말하면 n-1개의 부모 노드는 적어도 n-1개의 자식을 확실하게 확보하고 있다.<br /> 그니까 이게 뭔 말이냐면, 자식이 존재하는 노드를 internal node인데 root노드는 부모노드가 없는 노드이다. internal node가 있다는 것은 이 노드는 누군가의 자식이라는 거다. 즉 전체 internal node수인 n개에서 root노드를 제외하곤 부모와 연결하는 n-1개의 연결을 필요로 하게된다. <br /> 최종적으로 반드시 사용해야하는 n-1개를 2n개에서 빼면 n+1개의 자리가 남는다. 이 n+1개는 반드시 external nodes가 되게 된다.<li><p>$ n = 2e - 1$ 전체 노드의 개수는 n개인데, $ n = i + e$ 의 성질을 갖는다. 1번 식에 해당 식을 정리해서 대입하고 다시 정리하면 2번 식이 나오게된다.</p><li><p>$ h \leq i$ <br /> 트리의 높이는 internal node의 개수보다 작거나 같다. 이건 생각보다 생각하기 간단하다. 모든 노드가 한 줄로 쭉 연결된 상태라고하면, h와 i의 값이 같다. h는 자식이 하나 뻗을 때마다 1개씩 증가하기 때문이다.</p><li><p>$ h \leq (n - 1) / 2$ <br /> 이 식은 3번과 1,2번 식을 정리하면된다.<br /> \(n = 2e - 1 = 2(i + 1) - 1 = 2i + 1 \\ \therefore \; i = (n - 1) / 2\) <br /> 위의 계산과정을 3번에 대입하면 4번이 나온다.</p><li><p>$ e \leq 2^h$ <br /> 이건 3번의 증명과 좀 반대로 생각하고 좌우가 균형을 이후는 완전 이진트리를 그리면 된다.</p><li>$ h \geq log_{2}e, \;\;h\geq log_{2}(n+1) - 1$ <br /> 5번 식을 양변로그를 취하고 4번의 식을 합쳐주면 두 식이 나오게 된다.</ol><h1 id="이진트리-순회">이진트리 순회</h1><p>이진트리도 일종의 트리이다. 결국 순회가 존재하는데, 앞서 말했던 전위, 후위순회는 동일하게 진행되고 이진트리에만 있는 특수한 순회가 있다. 바로 중위순회 (inorder traversal)이다.<br /> 중위순회는 전위, 후위순회와 조금 다른 특징이라면 다음 자식을 가기 전에 자신을 거치고 간다는 점이다. 즉, 왼쪽-&gt;나-&gt;오른쪽의 탐색순서를 거친다는 의미이다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>Algorithm inOrder(v)
  if !v.isExternal()
    inOrder(v.left())

  visit(v)

  if !v.isExternal()
    inOrder(v.right())
</pre></table></code></div></div><p>중위순회는 다음과 같이 탐색한다.</p><p><img data-src="/image/DS/inorder.png" alt="inorder" data-proofer-ignore></p><p>사실 가만히 놓고 보면 모든 순회는 재귀함수 구현이 주를 이룬다.</p><h2 id="수식-출력">수식 출력 <a href="#수식-출력" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>중위순회를 사용하면 수식 출력이 가능하다.</p><p><img data-src="/image/DS/arith.png" alt="arith" data-proofer-ignore><br /> 위의 수식을 중위순회로 원래 수식으로 표현할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>Algorithm inOrder(v)
  if !v.isExternal()
    print('(')
    inOrder(v.left())

  print(v.element())

  if !v.isExternal()
    inOrder(v.right())
    print(')')
</pre></table></code></div></div><p>이렇게 코드를 작성하면 숫자 -&gt; 수식의 형태로 탐색하게된다. 출력결과는 잘 생각해보길… 코드를 따라가면서 해석하는 것도 중요하다.</p><h1 id="tree-implementation-트리-구현">Tree implementation (트리 구현)</h1><h2 id="node-prototype">Node prototype <a href="#node-prototype" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">parent</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">children</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="n">Node</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">insetChild</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">deleteChild</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">children</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{}</span>

  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Tree</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>이건 트리에 필요한 노드의 클래스이다. 트리에 들어가는 노드는 부모를 가리키는 노드 포인터와 자식 노드들을 저장하는 노드포인터 벡터가 존재한다. 트리에서 좀 더 쉽게 사용할 수 있는 insert와 delete가 있다.</p><h2 id="tree-prototype">Tree prototype <a href="#tree-prototype" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Node</span> <span class="p">{...};</span>

<span class="k">class</span> <span class="nc">Tree</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">heiht</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">node_list</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="n">Tree</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Tree</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Node</span><span class="o">*</span> <span class="n">getRoot</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">delNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">getHeight</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">printChild</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">countDepth</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">preorder</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">n</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">postorder</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">n</span><span class="p">);</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">findNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>생성자는 2개를 만들었다. 일반적으로 생성하는 기본생성자는 root node가 NULL값이고 특정 데이터를 갖는 노드를 루트로 하려면 두번째 생성자를 해주면된다. 멤버변수에 대해서 간단히 설명하자면, root는 말 그대로 루트노드를 말한다, node_list는 현재 트리에 저장된 노드를 저장하는 벡터이다. 이 트리의 저장형태를 간단히 표시하면 아래와 같다.</p><p><img data-src="/image/DS/nodesave.png" alt="node" data-proofer-ignore><br /> 우측의 배열이 좌측의 트리에 있는 node_list에 저장된 값들이고 해당 노드들의 children을 보여준다.</p><h3 id="getroot-getheight-function">getroot, getheight function <a href="#getroot-getheight-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">Node</span><span class="o">*</span> <span class="nf">getRoot</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">getHeight</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>두 함수는 간단하다. 그냥 요구하는 걸 반환해주면 된다.</p><h3 id="insert-function">insert function <a href="#insert-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">exist</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 부모노드가 있는 지 확인한다.</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node_list</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">exist</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

      <span class="n">Node</span><span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

      <span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
      <span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">insetChild</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
      <span class="n">v</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">exist</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">exist</code>변수는 자식을 추가하려고하는 부모노드의 존재를 확인하는 플래그 변수이다. 기본적으로 Node 클래스에 만들어 둔 insertChild 함수를 활용한다.<br /> 부모노드의 역할을 하는 노드에 있는 자식노드 리스트 벡터에 저장을 하는 원리이다.</p><ol><li>현재 있는 노드리스트에서 찾고자 하는 부모노드를 탐색한다.<li>찾은 노드의 자식 노드리스트 벡터에 새로운 노드인 자식노드를 넣어준다.<li>새롭게 만든 자식노드의 부모포인터를 현재 노드로 지정해준다.</ol><h3 id="delete-function">delete function <a href="#delete-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">delNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">exist</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node_list</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">exist</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">Node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 삭제하고자하는 노드의 자식을 모두 삭제 노드의 부모로 연결해준다.</span>
        <span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
      <span class="p">}</span>

      <span class="n">p</span><span class="o">-&gt;</span><span class="n">deleteChild</span><span class="p">(</span><span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="k">delete</span> <span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exist</span><span class="p">)</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>실제로 문제풀이 때 사용할 일이 없어서 구현은 안 했지만 이론상 설명을 하기위해서 직접 구현을 했다. 내가 배운 특정 노드 제거 방법은 제거하고자하는 노드의 자식들을 제거하는 노드의 부모 노드로 옮기는 과정으로 진행한다.</p><ol><li>삭제하고자하는 노드가 있는지 확인한다.<li>노드가 있다면 해당 노드의 자식노드리스트 크기만큼 돌려준다.<li>옮긴 부모 노드의 자식 노드리스트 벡터에 해당 자식들을 추가해준다.<li>모든 작업이 끝나면 해당 노드를 부모 노드에서 제거해준다.<li>최종적으로 원하는 노드를 제거한다.</ol><h3 id="count-depth-function">count depth function <a href="#count-depth-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">countDepth</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// return value;</span>
  <span class="kt">bool</span> <span class="n">exist</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node_list</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exist</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="c1">// depth 계산 시작 노드 탐색 완료 거꾸로 올라간다</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">d</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">exist</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>노드의 깊이는 현재 노드가 루트 노드를 만나러 올라갈 때까지 카운팅을 올려주면 된다.<br /> 노드를 찾고 역으로 타고 올라가면 된다.</p><ol><li>노드리스트에서 찾고자하는 노드를 탐색한다.<li>노드를 발견하면 현재 노드를 기준으로 계속해서 부모노드로 올라간다.<li>부모노드가 NULL인 루트노드를 발견하면 카운트를 멈춘다.</ol><h3 id="print-child-function">print child function <a href="#print-child-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">printChild</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">exist</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node_list</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">exist</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">exist</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>특정 노드의 자식 노드를 출력하는 함수이다. 코드는 길어보이나 아이디어는 간단하다.<br /> 필요로하는 노드를 node_list에서 찾고 그 노드의 자식 노드 벡터를 다 출력해주면 되는 것이다. 문제에서 요구하는 사항이 0이나 -1을 출력하는 것이 있어서 이것저것 많이 있게 되었다.<br /> 하지만 프로그래밍은 원래 예외처리가 중요하므로 해줄 필요가 충분히 있다.</p><h3 id="find-node-function">find node function <a href="#find-node-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">Node</span><span class="o">*</span> <span class="nf">findNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node_list</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">node_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>특정 노드를 탐색하는 함수이다. 앞서서 진행한 insert, delete, print등에 활용한 기반 함수를 활용하면 된다. 반복문으로 node_list에서 탐색하면 된다.</p><h3 id="preorder-function">preorder function <a href="#preorder-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tmp</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 자식이 있으므로 깊이 연산가능하다.</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Node</span><span class="o">*</span> <span class="n">child</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">preorder</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">height</span><span class="p">)</span>
      <span class="n">height</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

    <span class="n">tmp</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>전위순회 출력결과를 실행해주는 함수이다. 전위순회를 하는 동시에 전체 트리의 높이를 계산해주는 기능이 들어가있다.</p><ol><li>자신 노드의 값을 출력해준다.<li>자신에게 자식노드가 있다면 이제 전위순회를 시행한다.<li>각자 노드의 깊이를 계산해주는 임시 변수 tmp를 늘려준다.<li>자식 수만큼 반복문을 돌리며 자식에 대해서 전위순회를 재귀함수로 시행해준다.<li>만약 자식이 없는 리프노드에 도달할경우 다시 재귀 실행 이전으로 돌아오게 된다.<li>모든 반복문이 종료되고 높이를 갱신해준다.<li>자식이 있는 노드의 깊이 계산이 끝났으므로 재귀 실행 이전으로 돌아가기전에 높이를 줄여준다.</ol><p>if문 안에 있는 tmp를 늘리고 줄이는 순서의 위치는 향후에 그래프 탐색을 할 때 쓰는 DFS에서 사이클 내부에 존재하는 노드 개수 계산과도 큰 관련이 있으므로 기억해두면 좋다.</p><h3 id="postorder-function">postorder function <a href="#postorder-function" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Node</span><span class="o">*</span> <span class="n">child</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">postorder</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>후위순회는 전위순회에서 출력 순서만 맨 뒤로 옮겨주면 된다. 원리는 전위순회와 동일하다.</p><p>중위순회에 대한 내용은 <a href="https://cow-coding.tistory.com">티스토리 블로그</a> 트리 설명에 올려질 예정이다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/datastructure/'>DataStructure</a>, <a href='/categories/c/'>C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/datastructure/" class="post-tag no-text-decoration" >DataStructure</a> <a href="/tags/tree/" class="post-tag no-text-decoration" >Tree</a> <a href="/tags/binary-tree/" class="post-tag no-text-decoration" >Binary tree</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Data Structure] Binary Tree (이진트리) & Tree 구현 - Coding Gallery&url=https://cow-coding.github.io/posts/BTree/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Data Structure] Binary Tree (이진트리) & Tree 구현 - Coding Gallery&u=https://cow-coding.github.io/posts/BTree/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Data Structure] Binary Tree (이진트리) & Tree 구현 - Coding Gallery&url=https://cow-coding.github.io/posts/BTree/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/coursera2_3/">[MLOps Specialization / Step2] Labeling Data</a><li><a href="/posts/module/">[BoostCamp AI Tech / 심화포스팅] torch.nn.Module 뜯어먹기</a><li><a href="/posts/list/">[Deep Dive Python] 2. List</a><li><a href="/posts/variable/">[Deep Dive Python] 1. Python의 객체와 변수 개념</a><li><a href="/posts/final7/">[BoostCamp AI Tech / Final] Day91 - Airflow setting 및 배치 파이프라인 설계</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai-tech/">AI Tech</a> <a class="post-tag" href="/tags/boostcamp/">BoostCamp</a> <a class="post-tag" href="/tags/naver/">NAVER</a> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/mlops/">MLOps</a> <a class="post-tag" href="/tags/data-engineering/">Data Engineering</a> <a class="post-tag" href="/tags/project/">Project</a> <a class="post-tag" href="/tags/basic/">Basic</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/recommender-system/">Recommender System</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Tree/"><div class="card-body"> <em class="timeago small" date="2020-07-07 00:00:00 +0900" >Jul 7, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Data Structure] Tree (트리)</h3><div class="text-muted small"><p> Tree (트리) 트리 개념 트리는 non linear data structure이다. 앞서서 배운 리스트, 배열, 벡터는 모두 linear data structure이고 이런 선형 자료구조들은 원소들 간에 전/후 관계가 있다. 그러나 non linearr data structure, 즉 비선형 자료구조는 원소들 간에 상/하 관계를 가지고 있다. ...</p></div></div></a></div><div class="card"> <a href="/posts/BST/"><div class="card-body"> <em class="timeago small" date="2020-07-21 00:00:00 +0900" >Jul 21, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Data Structure] Binary Search Tree (이진 탐색 트리)</h3><div class="text-muted small"><p> Binary Search Tree (이진 탐색 트리) 이진 탐색 트리는 앞서서 배운 트리의 확장적인 형태라고 보면 편하다. 일반적인 이진 트리는 탐색의 기준이 없어서 특정 데이터를 찾으려면 모든 노드를 탐색해야한다. 하지만 이진 탐색 트리에서는 평균적으로 훨씬 빠른 시간에 탐색이 가능해진다. Binary Search (이진 탐색) 우선 이진 탐색...</p></div></div></a></div><div class="card"> <a href="/posts/LinkedList/"><div class="card-body"> <em class="timeago small" date="2020-06-30 00:00:00 +0900" >Jun 30, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Data Structure] Linked List (연결 리스트)</h3><div class="text-muted small"><p> Linked list (연결 리스트) 링크드 리스트와 배열 Linked list (연결 리스트)와 가장 많이 비교되는 자료구조에는 Array (배열)가 있다. 두 자료구조 모두 linear order data structure로, 선형 저장구조를 갖고 있다. 선형 저장구조를 갖고 있다는 의미는 데이터 간의 전후관계가 존재한다는 의미와도 같다. 두 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Tree/" class="btn btn-outline-primary" prompt="Older"><p>[Data Structure] Tree (트리)</p></a> <a href="/posts/PQ/" class="btn btn-outline-primary" prompt="Newer"><p>[Data Structure] Priority Queue (우선순위 큐)</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://cow-coding.github.io/posts/BTree/'; this.page.identifier = '/posts/BTree/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://cow-coding.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/cow-coding">Park Kibum</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai-tech/">AI Tech</a> <a class="post-tag" href="/tags/boostcamp/">BoostCamp</a> <a class="post-tag" href="/tags/naver/">NAVER</a> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/mlops/">MLOps</a> <a class="post-tag" href="/tags/data-engineering/">Data Engineering</a> <a class="post-tag" href="/tags/project/">Project</a> <a class="post-tag" href="/tags/basic/">Basic</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/recommender-system/">Recommender System</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { loader: {load: ['[tex]/color']}, chtml: { scale: 1.2 }, tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ], packages: {'[+]':['color']} } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-163727422-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-163727422-1'); }); </script>
