<!DOCTYPE html><html lang="en" data-mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="[Data Structure] Priority Queue (우선순위 큐)" /><meta property="og:locale" content="en" /><meta name="description" content="A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation." /><meta property="og:description" content="A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation." /><link rel="canonical" href="https://cow-coding.github.io/posts/PQ/" /><meta property="og:url" content="https://cow-coding.github.io/posts/PQ/" /><meta property="og:site_name" content="Coding Gallery" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-11T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Data Structure] Priority Queue (우선순위 큐)" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="TXb5nWUV5Ag0O8EVGMTUS11ZVi7BYOensPMiRdQGNRg" /> <script type="application/ld+json"> {"description":"A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.","url":"https://cow-coding.github.io/posts/PQ/","@type":"BlogPosting","headline":"[Data Structure] Priority Queue (우선순위 큐)","dateModified":"2022-01-14T02:41:57+09:00","datePublished":"2020-07-11T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://cow-coding.github.io/posts/PQ/"},"@context":"https://schema.org"}</script><title>[Data Structure] Priority Queue (우선순위 큐) | Coding Gallery</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Coding Gallery"><meta name="application-name" content="Coding Gallery"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4761810170892865" crossorigin="anonymous"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/my_img/icebear.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Coding Gallery</a></div><div class="site-subtitle font-italic">마침표를 찍고 조금 더 멀리</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/cow-coding" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['kbp0237','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Data Structure] Priority Queue (우선순위 큐)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Data Structure] Priority Queue (우선순위 큐)</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/cow-coding">Park Kibum</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2020-07-11 00:00:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Sat, Jul 11, 2020, 12:00 AM +0900" >Jul 11, 2020</em> </span> <span> Updated <em class="timeago" date="2022-01-14 02:41:57 +0900 " data-toggle="tooltip" data-placement="bottom" title="Fri, Jan 14, 2022, 2:41 AM +0900" >Jan 14, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4863 words"> <em>27 min</em> read</span></div></div></div><div class="post-content"><style> img { width:400px; display:block; margin:0px auto; }</style><h1 id="priority-queue-우선순위-큐">Priority Queue (우선순위 큐)</h1><p>이전에 <a href="https://cow-coding.github.io/data%20structure/2020/07/05/DS3_1/">큐에 대해서 배운 적</a>이 있다. 이렇게 일반적인 큐를 FIFO Queue라고 한다. FIFO원리를 갖고 있는 큐이기 때문이다.<br /> 이번 시간에는 다른 성질을 갖는 우선순위 큐에 대해서 이야기해보겠다.<br /> 우선순위 큐는 이름에 특징이 잘 나와있는데, 큐의 pop 연산수행을 진행할 때, 프로그래머가 정해놓은 우선순위에 맞춰서 제거 연산을 진행한다.<br /> 일반적으로는 우선순위 기준은 2가지인데,</p><ol><li>크기가 큰 값을 우선순위로 두는 Max-Priority-Queue<li>크키가 작은 값을 우선순위로 두는 Min-Priority-Queue</ol><p>가 있다. 우선순위 큐와 큐는 잘 알아둘 필요가 있는 이유가 있다. 이전 글에서 트리의 탐색 방식은 향후 그래프 탐색방법인 DFS와 일맥상통한다고 했다. 큐는 그래프 탐색방법 중 BFS에서 사용이 된다. 그리고 그런 BFS의 응용으로 사용하는 최단거리 계산 알고리즘인 다익스트라(Dijkstra) 알고리즘에서는 Min-Priority queue가 사용된다. 이 글에서는 Min-priority queue를 기준으로 구현하겠다.</p><h2 id="priority-queue-adt">Priority Queue ADT <a href="#priority-queue-adt" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>우선순위 큐는 entry들의 모임이다. 여기서 entry란 새롭게 나오는 개념인데, (key, value)조합으로 이루어진 데이터 쌍이다. value는 없는 경우도 있는데, key는 반드시 존재하게된다. key값으로 우선순위를 결정하기 때문이다.</p><ul><li>insert(e) : e라는 값을 가진 entry 삽입 (여기서는 e는 key가 된다.)<li>removeMin() : 가장 작은 값을 삭제해준다.<li>min() : 가장 작은 값을 반환해준다.<li>size()<li>empty()</ul><h1 id="우선순위-큐-구현방법">우선순위 큐 구현방법</h1><p>우선순위 큐 구현방법에는 3가지 방식이 존재한다. 이유는 정렬 방식때문인데, 가장 효율적인 방법은 힙(heap)방식으로 구현하는 것이다.</p><ul><li>unsorted sequence<li>sorted sequence<li>heap</ul><h2 id="sequence-based-priority-queue">Sequence based Priority Queue <a href="#sequence-based-priority-queue" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>시퀀스 기반의 우선순위 큐에는 2가지가 있는데, unsorted방식과 sorted방식이다. 이 두 가지 방식의 구현 원리를 설명해보겠다.</p><h3 id="unsorted-sequence--selection-sort">Unsorted Sequence &amp; Selection sort <a href="#unsorted-sequence--selection-sort" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>기본 함수의 소요시간 비정렬 방식의 삽입연산에는 $ O(1)$ 의 시간이 소요된다. 이유는 가장 마지막이나 가장 앞에 데이터를 넣어주기만 하면되기 때문이다. removeMin 연산이나 최소를 반환하는 연산같이 탐색을 동반하는 연산은 모두 $ O(n)$ 시간을 요구한다. 왜냐하면 전체 데이터에서 가장 작은 값을 찾기 위해서는 모든 값을 확인해야하기 때문이다.<li>선택정렬 (Selection sort) 비정렬 방식으로 만든 우선순위 큐를 사용하는 정렬방식이 선택정렬이다. 정렬하고자하는 sequence의 내부 데이터를 모두 우선순위 큐에 넣었다가 다시 앞에서부터 제거하면서 빼내는 절차를 거쳐야한다.<ul><li>선택정렬의 삽입 과정에서는 $ O(n)$ 시간이 소요된다. 이유는 간단하다. 우선 비정렬 시퀀스에 넣은 값을 다시 앞에서부터 우선순위 큐에 삽입해주기 때문이다. 그래서 총 n번의 $ O(1)$ 연산이 수행되므로 총 $ O(n)$ 시간이 소요된다.<li>선택정렬에서 removeMin은 $ O(n^2)$ 시간이 소요된다. 앞서 말했듯이 비정렬방식에서는 removeMin을 위해서는 저장된 데이터만큼의 탐색을 진행해야한다. 그래서 총 n개라 했을 때 n번 탐색, 이후 n-1번 탐색을 1번 탐색까지 반복하므로 등차수열 합 공식을 적용 시킬 수 있다.<br /> \(\sum_{k=1}^{n}k = \frac{n(n+1)}{2}\)</ul></ul><h3 id="sorted-sequence--insertion-sort">Sorted Sequence &amp; Insertion sort <a href="#sorted-sequence--insertion-sort" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>기본 함수의 소요시간 정렬 방식에서 삽입연산은 $ O(n)$ 시간이 소요된다. 해당 데이터가 들어가기 가장 좋은 위치를 탐색해야하기 때문이다. 정확히 말하면 데이터를 삽입하는 동시에 삽입정렬이 이루어지기 때문이다.<br /> removeMin은 이미 삽입당시 정렬이 이루어졌으므로 $ O(1)$ 시간으로 가장 앞에 데이터를 제거해주면 된다.<li>삽입정렬 (Insertion sort) 정렬 방식으로 구현한 우선순위 큐를 사용하는 정렬방식이 삽입정렬이다. 정렬하고자하는 sequence의 내부 데이터를 모두 우선순위 큐에 넣었다가 다시 앞에서부터 제거하면서 빼내는 절차를 거쳐야한다.<ul><li>삽입정렬의 삽입과정은 $ O(n^2)$ 의 시간이 사용된다. 우리가 정렬하고자 하는 시퀀스의 데이터를 우선순위 큐에 넣을 때 우선순위 큐에 들어온 데이터의 크기만큼 탐색을하며 자신이 들어갈 위치를 찾는다. 결국 전체 데이터만큼 탐색을 해야하는데, 이때 $ O(n)$ 시간이 걸리게된다. 선택정렬에서 제거하는 원리처럼 등차수열 합공식에 의해서 $ O(n^2)$ 시간이 걸린다.<li>다행히 removeMin은 $ O(n)$ 시간이 걸린다. 가장 앞의 데이터를 빼주면 되므로 $ O(1)$ 만큼의 연산은 전체 데이터 횟수만큼 해주기 때문이다.</ul></ul><h1 id="heap-힙">Heap (힙)</h1><p>힙은 우선순위 큐의 구현방법 중 하나이다. 완전이진트리 구조로 데이터를 저장하고 있다. 우선순위 큐의 구현을 위한 것이므로 entry를 저장하고 있다. 힙에 반드시 필요한 2가지가 있다.</p><ul><li>heap-order : 힙 순서는 힙에서 데이터 삽입과 제거 과정에서 필요한 것이다. 부모와 자신의 데이터를 비교해서 두 노드의 정보를 바꿔줄 필요가 있다.<li>완전 이진트리 구조 : 노드의 제거와 삽입에서 사용하는 upHeap과 downHeap과정에서 좌우 노드의 탐색이 필요하기 때문에 반드시 왼쪽부터 꽉 채워지는 완전 이진트리 구조를 가져야한다.<li>last node : 삽입하는 과정에서 보다는 제거하는 과정에서 필요한 마지막 노드를 가져오는 last node의 정보를 가져와야한다. last node는 말 그대로 가장 깊이 있는 노드 중 하나이다.</ul><h2 id="힙의-깊이와-노드-개수의-연관성">힙의 깊이와 노드 개수의 연관성 <a href="#힙의-깊이와-노드-개수의-연관성" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>힙의 깊이와 노드 개수는 연관성이 깊다. 왜 갑자기 힙 트리의 높이를 계산하냐면 이후에 필요한 upHeap이나 downHeap 과정은 힙 트리의 높이가 결국 수행시간을 결정하게 되기 때문이다.<br /> 완전 이진트리를 기준으로 할 때, 현재 이진트리가 h-1까지 구성되어있고 새로 데이터를 넣으면 깊이 h에 새로운 노드가 삽입되는 상황이라고 하자.</p><p><img data-src="/image/DS/h1.png" alt="h1" data-proofer-ignore></p><p>현재까지 노드개수를 수식으로 표현하면 다음과 같다.<br /> \(1 + 2+ 2^{2}+...+2^{h-1}=\frac{1(2^h -1)}{2-1}=2^h -1\) <br /> 깊이가 h-1인 상황에서 완전 이진트리가 되어 있는 경우는 $ 2^h -1$ 개의 노드가 있다. 여기서 만약 노드가 1개 추가된다면 h높이에 노드가 1개 추가된다.</p><p><img data-src="/image/DS/h2.png" alt="h2" data-proofer-ignore></p><p>이전까지 $ 2^h -1$ 개의 노드가 1개가 추가되면서 $ 2^h$ 개가 된다. 즉 h높이 트리 노드 개수는 다음과 같은 수식을 만족한다.<br /> \(n \geq 2^h \rightarrow \; h \leq \log_{2}{n}\) <br /> 결과적으로 높이와 관련된 연산은 $ O(logn)$ 연산 수행시간이 걸린다.</p><h2 id="insertion-of-heap-힙의-삽입과정">insertion of heap (힙의 삽입과정) <a href="#insertion-of-heap-힙의-삽입과정" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>힙은 새로운 노드를 삽입하거나 제거를 했을 때 기본적으로 데이터가 정리가 되어 있는 트리의 형태를 띄게된다.<br /> 우선순위 큐의 구현을 위해 만들어지므로 어떻게 보면 데이터 정렬이 당연해질 수 있다. 최소 힙을 기준으로 할 때, 루트 노드는 자연스럽게 가장 작은 값을 갖게되고 리프노드일수록 큰 값을 갖게된다.</p><p><img data-src="/image/DS/insert1.png" alt="insert1" data-proofer-ignore></p><p><img data-src="/image/DS/insert2.png" alt="insert2" data-proofer-ignore></p><p><img data-src="/image/DS/insert3.png" alt="insert3" data-proofer-ignore></p><ol><li>새로 들어 온 노드와 자신의 부모노드와 크기 비교를 한다.<li>자신의 부모노드가 자신의 값보다 크기가 크다면 둘의 데이터를 바꿔준다. 아니라면 그대로 유지하고 함수를 종료<li>1번과 2번을 바꿀 수 없을 때까지 반복해준다.</ol><p>두 노드의 값을 변경하는 과정은 $ O(1)$ 시간이 소요된다. 이 과정을 최악의 경우 (리프 -&gt; 루트)에 트리의 높이만큼 swap을 해줘야한다. 위에서 h는 아무리 최악이라도 $ \log_{2}{n}$ 을 넘을 수 없다. 결국 힙의 삽입과정에서 소요되는 총 시간은 $ O(\log{n})$ 시간이다.<br /> 이렇게 힙의 삽입과정에서 정렬을 해주는 과정을 upheap이라고 한다. 위로 올라가는 형태이기 때문에 붙여진 이름이라고 생각하면된다.</p><h2 id="removal-of-heap-힙의-삭제과정">removal of heap (힙의 삭제과정) <a href="#removal-of-heap-힙의-삭제과정" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>힙에서 삭제를 하게 될 경우 루트노드를 제거하게된다. 왜 루트노드를 제거하냐면 힙은 우선순위 큐의 구현을 위해 만들어진 방식인데, 우선순위 큐는 특정한 기준치를 따라서 Out과정이 이루어진다. 그 특정한 기준치로 데이터를 높이별로 정렬을 시킨 것이 바로 heap이기 때문이다.<br /> 그렇다면 루트 노드가 제거되었다면 그 자리는 누가 차지하게 되는 걸까? 그 자리는 가장 마지막 노드가 우선적으로 차지하게 된다.</p><p><img data-src="/image/DS/del1.png" alt="del1" data-proofer-ignore></p><p><img data-src="/image/DS/del2.png" alt="del2" data-proofer-ignore></p><p><img data-src="/image/DS/del3.png" alt="del3" data-proofer-ignore></p><ol><li>우선 루트노드를 제거한다. 제거하기 이전에 가장 마지막 노드를 저장해준다. (가장 마지막 노드를 지시하는 방법은 힙의 크기를 저장하는 변수로 지시해주면 된다.)<li>그 후 루트노드 위치 (벡터 인덱스 1번)에 저장해 둔 마지막 노드 데이터를 넣어준다. 그와 동시에 마지막 노드 데이터를 벡터에서 제거해준다.<li>그 후 자식 노드에서 더 작을 것과 위치를 바꿔준다.<li>3번 과정을 더 이상 바꿀 수 없을 때까지 반복한다.</ol><p>이 과정도 삽입과 동일하게 $ \log_{2}{n}\시간이 소요된다. 자식과 데이터를 바꾸는 과정은 downheap이라고 하는데, 사실 upheap은 루트노드라는 쉬운 종결조건이 있다. 하지만 downheap은 조건이 명확하지 않으면 벡터의 out of index에러를 마주친다.<br /> 종결조건은 자신의 key값이 자신의 자식들의 key값 중 어떤 것보다도 크지 않거나 본인의 위치가 리프노드면 종결한다.</p><h1 id="heap-implementation-힙-구현">Heap implementation (힙 구현)</h1><h2 id="heap-prototype">Heap prototype <a href="#heap-prototype" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">direction</span> <span class="p">{</span> <span class="n">MIN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MAX</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">Heap</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Node</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">heap_size</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">root_idx</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">direction</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="n">Heap</span><span class="p">(</span><span class="kt">int</span> <span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">heap_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">root_idx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">Swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx2</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">upHeap</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">downHeap</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">pop</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">top</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">empty</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">print</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">at</span><span class="p">();</span>
<span class="p">};</span>
</pre></table></code></div></div><p>특별히 설명하고 넘어갈 부분은 enum class파트의 역할과 벡터에 -1을 넣고 시작하는 이유정도이다.<br /> 우선 enum class인 direction의 역할은 Max heap과 Min heap을 결정해준다. 여기서 왜 MIN이 1이고 MAX가 -1이냐면, 기본적으로 이후에 진행할 upHeap과 downHeap과정에서 부등호로 대소비교를 해준다. 우리가 구현할 힙은 최소 힙을 기준으로 하므로 우선 MIN이 1이 된다. 여기서 부등호에 -1을 곱해주면 부등호 방향이 바뀜을 활용해주면 된다. 그래서 MAX가 -1이 되는 것이다.<br /> 벡터에 -1이 먼저 들어가는 이유는 간단하다. 우리는 앞서서 본 트리에서 벡터나 배열로 이진트리를 구현할 경우를 생각해봤다. 이진트리의 특성상 left child의 인덱스는 parent index * 2와 같고 right child는 left child + 1의 인덱스를 갖는다. 이런 성질은 문제없이 활용하기 위해서는 어떤 수에 0을 곱해도 0인 0번 인덱스를 피하고 데이터를 다뤄줘야한다. 그래서 우선적으로 0번 인덱스에 의미없는 수를 넣어준다.</p><h2 id="empty-size-top-at-function">empty, size, top, at function <a href="#empty-size-top-at-function" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">heap_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">heap_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">top</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Node</span><span class="p">[</span><span class="n">root_idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Node</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><p>간단한 반환 함수들이다. 설명은 생략…</p><h2 id="swap-function">Swap function <a href="#swap-function" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">Node</span><span class="p">[</span><span class="n">idx1</span><span class="p">];</span>
  <span class="n">Node</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Node</span><span class="p">[</span><span class="n">idx2</span><span class="p">];</span>
  <span class="n">Node</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>일반적인 swap과 유사하다. 여기서 조금 주의해야할 점은 이름의 s는 반드시 대문자로 설정해주다. Visual Studio에는 기본적으로 swap이 있는데, 이게 헤더를 추가하지 않아도 사용이 가능한 구현함수라 사용할 때 문제가 발생할 수 있다.</p><h2 id="upheap-function">upheap function <a href="#upheap-function" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">upHeap</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">Node</span><span class="p">[</span><span class="n">idx</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">direction</span> <span class="o">*</span> <span class="n">Node</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">Swap</span><span class="p">(</span><span class="n">idx</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
    <span class="n">upHeap</span><span class="p">(</span><span class="n">idx</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>heap에서 가장 중요한 함수 중 하나인 upheap 함수다. upheap을 진행할 때 기억할 중요한 점은 <strong>부모의 값과 자신의 값 비교</strong> 이다. C++성질상 나눗셈의 최솟값은 0이므로 무조건 0번 인덱스까지만 간다. 그래서 그냥 단순 재귀로 계속 연산해주면 된다. 재귀 실행조건은 간단하다. 부모가 나보다 큰 경우이다. 이 경우에는 위에서 구현한 Swap을 실행시켜주고 다시 재귀로 upheap을 돌려주면된다. 재귀로 돌려줄 때는 자신이 이미 부모와 위치가 바뀌었으므로 부모인덱스를 인덱스로 넣어준다.</p><h2 id="downheap-function">downheap function <a href="#downheap-function" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">downHeap</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">small</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;=</span> <span class="n">heap_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">Node</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">direction</span> <span class="o">*</span> <span class="n">Node</span><span class="p">[</span><span class="n">right</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">small</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">heap_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">small</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">Node</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">direction</span> <span class="o">*</span> <span class="n">Node</span><span class="p">[</span><span class="n">small</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">Swap</span><span class="p">(</span><span class="n">small</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
    <span class="n">downHeap</span><span class="p">(</span><span class="n">small</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>heap구현에서 가장 어려운 부분이지 않을까 싶은 downheap이다. 앞에서 말한 downheap의 조건을 우선 잘 적어보자.</p><ol><li>자신이 리프노드에 도달하면 멈춘다.<li>자신보다 자신의 자식중 작은 자식이 자신보다 작지 않으면 멈춘다.</ol><p>이걸 잘 생각해보면 우선 우리가 해줘야 할 작업이 몇 가지가 있다.</p><ol><li>어떻게 하면 지금 내가 있는 위치가 리프노드인지 알 수 있을까?<ul><li>이건 어렵지 않다. 힙의 기본조건은 완전 이진트리라는 것이다. 우리는 이미 삽입과 삭제를 할 때, 힙에 저장된 노드 수를 기록하는 heap_size를 갖고 있다. 이진트리 성질에 따라서 만약 right나 left노드의 인덱스가 heap_size를 넘었다면 적어도 현재 노드에는 자식이 존재할 수 없다는 의미가 된다. 그러면 현재 노드는 자연스럽게 리프노드가 된다.<br /> 위의 코드에서는 첫번째 if~else if문이 그 역할을 한다.</ul><li>자신의 자식 중 작은 것을 찾아야 한다.<ul><li>만약 내가 리프노드가 아니고 자식이 있다는 것을 파악했다면, 이제 자식 중 작은 값을 찾아내서 나와 비교 후 자리를 바꿔줘야한다. 첫번째 if~else문에서 리프노드가 아님을 파악했다면, 내가 자식이 1개인지, 2개인지 알아볼 필요도 있다.<br /> right가 heap_size보다 작거나 같다는 의미는 나에게 자식이 2개가 있다는 의미가 된다. 완전 이진트리의 특징상 right node index는 left node index보다 무조건 클 수 밖에 없기 때문이다. 그리고 left가 없다면 right도 있을 수 없기 때문이다. 즉 right가 존재할 때만 left와 right의 값을 비교해준다.<br /> left만 있다면 비교할 인덱스는 left 하나 뿐이다.</ul></ol><p>그 후 upheap과 유사하게 재귀로 진행을 해주면된다. 우리가 고려해줄 것들은 이미 위쪽의 if~else문에서 다 고려해줬다.</p><h2 id="insert-pop-function">insert, pop function <a href="#insert-pop-function" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
  <span class="n">heap_size</span><span class="o">++</span><span class="p">;</span>

  <span class="n">upHeap</span><span class="p">(</span><span class="n">heap_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">Node</span><span class="p">[</span><span class="n">heap_size</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">Node</span><span class="p">[</span><span class="n">root_idx</span><span class="p">];</span>

  <span class="n">Node</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">Node</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">heap_size</span><span class="p">);</span>
  <span class="n">Node</span><span class="p">[</span><span class="n">root_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="n">heap_size</span><span class="o">--</span><span class="p">;</span>
  <span class="n">downHeap</span><span class="p">(</span><span class="n">root_idx</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>우선 삽입함수부터 설명을 해보면, 간단하다. 앞서 말했듯이 우선 노드를 넣어주고 upheap과정을 통해 정렬을 진행해주면 된다.</p><p>조금 복잡한 제거함수이다. 우선 제거관련이므로 당연하게 공백여부를 체크해준다. 그 후 마지막노드 값을 임시적으로 보관해준다. 이 값은 제거된 root에 대신 들어가게된다.<br /> 말은 root를 없애는 것처럼 보이지만 실제로는 root의 값만 바꾸고 실제 제거되는 데이터 위치는 마지막 노드의 위치이다. vector function으로 마지막 노드부분을 제거해준다.<br /> 그 후 root의 값을 마지막 노드 값으로 바꾸고 downheap을 진행해주면된다.<br /> 당연히 반환 값은 root에 저장되었던 값.</p><h2 id="print-function">print function <a href="#print-function" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">empty</span><span class="p">()){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">heap_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Node</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>출력함수에서 주의할 점은 우리가 1번 인덱스부터 데이터를 처리했다는 것이다. 이 점을 주의하면서 heap size에 맞춰서 돌려주면된다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/datastructure/'>DataStructure</a>, <a href='/categories/c/'>C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/datastructure/" class="post-tag no-text-decoration" >DataStructure</a> <a href="/tags/priority-queue/" class="post-tag no-text-decoration" >Priority Queue</a> <a href="/tags/heap/" class="post-tag no-text-decoration" >heap</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Data Structure] Priority Queue (우선순위 큐) - Coding Gallery&url=https://cow-coding.github.io/posts/PQ/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Data Structure] Priority Queue (우선순위 큐) - Coding Gallery&u=https://cow-coding.github.io/posts/PQ/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Data Structure] Priority Queue (우선순위 큐) - Coding Gallery&url=https://cow-coding.github.io/posts/PQ/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/coursera2_3/">[MLOps Specialization / Step2] Labeling Data</a><li><a href="/posts/module/">[BoostCamp AI Tech / 심화포스팅] torch.nn.Module 뜯어먹기</a><li><a href="/posts/list/">[Deep Dive Python] 2. List</a><li><a href="/posts/variable/">[Deep Dive Python] 1. Python의 객체와 변수 개념</a><li><a href="/posts/final7/">[BoostCamp AI Tech / Final] Day91 - Airflow setting 및 배치 파이프라인 설계</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai-tech/">AI Tech</a> <a class="post-tag" href="/tags/boostcamp/">BoostCamp</a> <a class="post-tag" href="/tags/naver/">NAVER</a> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/mlops/">MLOps</a> <a class="post-tag" href="/tags/data-engineering/">Data Engineering</a> <a class="post-tag" href="/tags/project/">Project</a> <a class="post-tag" href="/tags/basic/">Basic</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/recommender-system/">Recommender System</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/LinkedList/"><div class="card-body"> <em class="timeago small" date="2020-06-30 00:00:00 +0900" >Jun 30, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Data Structure] Linked List (연결 리스트)</h3><div class="text-muted small"><p> Linked list (연결 리스트) 링크드 리스트와 배열 Linked list (연결 리스트)와 가장 많이 비교되는 자료구조에는 Array (배열)가 있다. 두 자료구조 모두 linear order data structure로, 선형 저장구조를 갖고 있다. 선형 저장구조를 갖고 있다는 의미는 데이터 간의 전후관계가 존재한다는 의미와도 같다. 두 ...</p></div></div></a></div><div class="card"> <a href="/posts/AnalysisAlgorithm/"><div class="card-body"> <em class="timeago small" date="2020-07-03 00:00:00 +0900" >Jul 3, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Data Structure] Analysis of Algorithms (알고리즘 분석)</h3><div class="text-muted small"><p> Algorithm Analysis (알고리즘 분석) Asymtotic Analysis (점근적 분석) 알고리즘을 비교, 분석할 때는 일반적으로 점근적 분석방법을 따른다. 점근적 분석방법은 아래의 과정들로 진행된다. 의사코드 (pseudo code) 연산자 개수 카운트 (primitive operation counting) input s...</p></div></div></a></div><div class="card"> <a href="/posts/Stack/"><div class="card-body"> <em class="timeago small" date="2020-07-04 00:00:00 +0900" >Jul 4, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Data Structure] Stack(스택)</h3><div class="text-muted small"><p> Abstract Data Types (추상 자료형) 추상 자료형 (ADTs)는 한마디로 말하면 알고리즘의 요약본이다. ADT는 correctness와 performance를 독립적으로 생각하게 해줄 수 있다. Correctness는 일반적으로 interface라고도 하는데, input이 들어왔을 때, output의 일치 정확도가 얼마나 높은 가를 말한...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/BTree/" class="btn btn-outline-primary" prompt="Older"><p>[Data Structure] Binary Tree (이진트리) & Tree 구현</p></a> <a href="/posts/Hash/" class="btn btn-outline-primary" prompt="Newer"><p>[Data Structure] Hash (해시)</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://cow-coding.github.io/posts/PQ/'; this.page.identifier = '/posts/PQ/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://cow-coding.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/cow-coding">Park Kibum</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai-tech/">AI Tech</a> <a class="post-tag" href="/tags/boostcamp/">BoostCamp</a> <a class="post-tag" href="/tags/naver/">NAVER</a> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/mlops/">MLOps</a> <a class="post-tag" href="/tags/data-engineering/">Data Engineering</a> <a class="post-tag" href="/tags/project/">Project</a> <a class="post-tag" href="/tags/basic/">Basic</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/recommender-system/">Recommender System</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { loader: {load: ['[tex]/color']}, chtml: { scale: 1.2 }, tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ], packages: {'[+]':['color']} } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-163727422-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-163727422-1'); }); </script>
