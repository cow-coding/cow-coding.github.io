<!DOCTYPE html><html lang="en" data-mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="[Data Structure] Vector and List (벡터와 리스트)" /><meta property="og:locale" content="en" /><meta name="description" content="Vector (벡터) 벡터 개념 벡터는 크기가 동적으로 변하는 배열이라고 생각하면 된다. Array list라고 부르기도 하며 다양한 데이터들이 배열의 형태로 저장된 연속체라고 생각하면 된다. 삽입, 삭제, 접근 연산이 모두 index에의해 이뤄지게 된다." /><meta property="og:description" content="Vector (벡터) 벡터 개념 벡터는 크기가 동적으로 변하는 배열이라고 생각하면 된다. Array list라고 부르기도 하며 다양한 데이터들이 배열의 형태로 저장된 연속체라고 생각하면 된다. 삽입, 삭제, 접근 연산이 모두 index에의해 이뤄지게 된다." /><link rel="canonical" href="https://cow-coding.github.io/posts/Vector/" /><meta property="og:url" content="https://cow-coding.github.io/posts/Vector/" /><meta property="og:site_name" content="Coding Gallery" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-06T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Data Structure] Vector and List (벡터와 리스트)" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="TXb5nWUV5Ag0O8EVGMTUS11ZVi7BYOensPMiRdQGNRg" /> <script type="application/ld+json"> {"description":"Vector (벡터) 벡터 개념 벡터는 크기가 동적으로 변하는 배열이라고 생각하면 된다. Array list라고 부르기도 하며 다양한 데이터들이 배열의 형태로 저장된 연속체라고 생각하면 된다. 삽입, 삭제, 접근 연산이 모두 index에의해 이뤄지게 된다.","url":"https://cow-coding.github.io/posts/Vector/","@type":"BlogPosting","headline":"[Data Structure] Vector and List (벡터와 리스트)","dateModified":"2022-01-14T02:41:57+09:00","datePublished":"2020-07-06T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://cow-coding.github.io/posts/Vector/"},"@context":"https://schema.org"}</script><title>[Data Structure] Vector and List (벡터와 리스트) | Coding Gallery</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Coding Gallery"><meta name="application-name" content="Coding Gallery"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4761810170892865" crossorigin="anonymous"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/my_img/icebear.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Coding Gallery</a></div><div class="site-subtitle font-italic">마침표를 찍고 조금 더 멀리</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/cow-coding" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['kbp0237','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Data Structure] Vector and List (벡터와 리스트)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Data Structure] Vector and List (벡터와 리스트)</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/cow-coding">Park Kibum</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2020-07-06 00:00:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Mon, Jul 6, 2020, 12:00 AM +0900" >Jul 6, 2020</em> </span> <span> Updated <em class="timeago" date="2022-01-14 02:41:57 +0900 " data-toggle="tooltip" data-placement="bottom" title="Fri, Jan 14, 2022, 2:41 AM +0900" >Jan 14, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3517 words"> <em>19 min</em> read</span></div></div></div><div class="post-content"><style> img { width:300px; display:block; margin:0px auto; }</style><h1 id="vector-벡터">Vector (벡터)</h1><h2 id="벡터-개념">벡터 개념 <a href="#벡터-개념" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>벡터는 크기가 동적으로 변하는 배열이라고 생각하면 된다. Array list라고 부르기도 하며 다양한 데이터들이 배열의 형태로 저장된 연속체라고 생각하면 된다.<br /> 삽입, 삭제, 접근 연산이 모두 index에의해 이뤄지게 된다.</p><h2 id="vector-adt">Vector ADT <a href="#vector-adt" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>벡터의 추상자료형은 다음과 같다.</p><ul><li>at(integer i) : index i에대해서 데이터 값을 반환해준다.<li>set(integer i, object o) : index i의 데이터를 o로 바꿔준다.<li>insert(integer i, object o) : index i에 o를 삽입한다.<li>earase(integer i) : index i에 있는 데이터를 제거해준다.<li>size() : 벡터의 크기를 반환해준다.<li>empty() : 벡터가 비었는 지를 알려준다.</ul><h2 id="벡터의-시간복잡도">벡터의 시간복잡도 <a href="#벡터의-시간복잡도" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>벡터는 위에서 말했듯이 링크드 리스트와 다르게 인덱스로 모든 데이터에 접근하여 삽입, 삭제가 이뤄진다. 그렇기 때문에 해당 인덱스의 데이터를 가져오거나, 설정해주는 at과 set은 $ O(1)$ 의 시간복잡도를 갖는다.<li>그러나 삽입연산과 삭제연산을 하는 inset와 remove는 $ O(n)$ 의 시간복잡도를 갖는데, 이유는 해당 인덱스의 값을 넣거나 삭제를 함과 동시에 그 이후의 데이터들을 모두 움직여줘야 하기 때문이다. 하지만 이것은 선형 배열로 구현할 경우이고, 원형 배열기반으로 구현하면 이 또한 $ O(1)$ 의 시간복잡도로 구현할 수 있다.<br /> 자세한 설명은 구현에서 설명하겠다.</ul><h1 id="array-based-vector">Array-based Vector</h1><p>벡터를 구현할 때 보통 배열 기반으로 구현하게 된다. 기존 C++STL에 있는 벡터는 초기에 설정된 크기를 넘는 경우에는 이전에 있는 크기의 2배만큼으로 크기를 늘려주게된다. 이러한 방법을 사용해도 괜찮고, 원형 배열을 사용하는 경우도 있다. 원형 배열을 사용하는 방식은 간단히 설명하고 넘어가겠다.</p><h2 id="vector-by-circular-array">Vector by Circular Array <a href="#vector-by-circular-array" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>원형 배열 기반의 벡터에 대해서 자세한 설명은 삽입연산과 삭제연산의 원리에 대해서만 설명하겠다. 그 외는 단순히 값을 반환하거나 바꿔주기만 하면 되는 간단한 대입연산이다.</p><h3 id="삽입연산">삽입연산 <a href="#삽입연산" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>배열 기반 벡터는 가장 앞의 인덱스를 알려주는 f와 가장 뒤의 인덱스+1을 알려주는 r이 있다. 일반적으로 데이터가 들어가 있을 때, f는 가장 앞의 데이터가 저장된 인덱스를 가리키고 있다.<br /> 즉 사용자 입장에서는 0번 인덱스에 f가 있다. 하지만 실제로 사용되는 배열은 원형 배열이라 f의 인덱스가 반드시 0번이라는 보장은 없다.<br /> 그래서 보통 삽입 연산의 방식은 <code class="language-plaintext highlighter-rouge">A[(f + i) % n] = o</code>의 형식으로 작성된다.<br /> 문제는 가장 앞에 데이터를 삽입하는 경우인데, 이 경우에는 f-1로 이동시켜서 값을 넣어주면된다.<br /> 하지만 0번 인덱스에서 -1을 하는 문제를 막기위해서 <code class="language-plaintext highlighter-rouge">A[(f-1+n)%n]</code>의 방식으로 작동시켜준다. 삭제연산도 유사한 원리로 작동한다.</p><h2 id="vector-by-normal-array">Vector by Normal Array <a href="#vector-by-normal-array" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>일반적인 배열로 벡터를 구현을 할 경우는 앞서 말한 원리처럼 배열의 크기를 늘려주는 작업도 고려해야한다.<br /> 배열의 크기를 늘리는 전략에는 2가지 전략이 있는데, Incremental strategy와 Doubling strategy가 있다.<br /> Incremental Strategy는 상수 크기만큼 배열의 크기를 증가시키는 것이다. 100-&gt;200-&gt;300…처럼 특정 상수 크기만큼 증가시킨다.<br /> Doubling Strategy는 이전 크기의 2배만큼 크기를 증가시킨다. 100-&gt;200-&gt;400 이런 식으로 증가시키며 일반적인 벡터의 크기 증가 방법이 이렇다.</p><h3 id="삽입연산-1">삽입연산 <a href="#삽입연산-1" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>일반 배열로 구현한 벡터의 삽입연산은 아래와 같이 작성할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>Algorithm inset(o)
  if n = N then
    N &lt;- 2N {Doubling}
    A &lt;- new array of size N

    for i&lt;-0 to n-1 do
      A[i] &lt;- S[i]

    delete S

    S &lt;- A

  S[n] &lt;- o
  n &lt;- n+1
</pre></table></code></div></div><p>우선 크기를 늘릴 배열 A를 새롭게 선언해준다. 당연히 선언 이전에 N의 크기는 2배로 늘려준다. 그 후 기존 배열을 삭제하기위해 기존 배열의 데이터를 새로 만든 A에 복사해준다. 그 후 S를 A로 대입해주면 된다. 이렇게 하면 Doubling Strategy를 활용한 기존의 벡터를 구현할 수 있다.</p><h1 id="list">List</h1><p>리스트는 앞선에서 배운 링크드 리스트관련의 C++ STL이다. 이미 C++ 기본 라이브러리에 구현이 되어 있으며 리스트는 인덱스가 아닌 position이라는 개념을 활용한다.</p><h2 id="position-adt">Position ADT <a href="#position-adt" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>리스트는 벡터나 배열형태의 자료구조에서 사용되는 index를 사용하지 않고 memory상의 주소를 갖고있는 position이라는 개념을 사용한다. 해당 데이터가 저장되어있는 위치를 가져온다. <br /> 대표적인 예시로는…</p><ul><li>배열의 cell도 position이다 <del>물론 배열은 position이 아니라 index라고 부른다.</del><li>링크드 리스트의 노드</ul><p>주소를 저장하고 있다는 점에서 문득 스쳐지나가는 개념이 하나 있다면 C++에대한 기초공부를 굉장히 잘했다고 볼 수 있다. C++에는 따로 멤버함수로 position을 가지고 있지 않고 주소값을 가지고 있는 포인터(pointer)를 갖고있다.</p><h2 id="node-list-adt">Node List ADT <a href="#node-list-adt" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>리스트의 추상 자료형은 다음과 같은 것들이 있다.</p><ul><li>size(), empty() : 앞선에서도 많이 다룬 것들이다.<li>iterator<ul><li>begin() : 리스트의 시작부분의 주소를 반환해준다.<li>end() : 리스트의 마지막부분의 주소를 반환해준다.</ul><li>insertFront(e), insertBack(e)<li>removeFront(), removeBack()<li>insert(position, e)<li>remove(position)</ul><p>이전에 다뤘던 ADT들과 조금 다른 것이 추가되었다.<br /> 바로 iterator라는 개념이다. 실제로 벡터나 리스트관련을 STL로 사용할 때 자주 사용하게되는 개념이다.<br /> iterator는 일종의 navigater역할이다. position이 확장된 개념인데 주소 값을 지시하는 역할을 하게된다. 여기서 end()를 마지막 주소를 반환해준다고 했는데, 실제로는 마지막의 다음 주소를 가지고 있다. 그래서 보통 반복문으로 iterator를 변경할 때, 조건문에는 <code class="language-plaintext highlighter-rouge">i.end()</code>와 같지 않을 때까지라는 조건을 붙인다.<br /> 가장 마지막의 2개 함수는 특정 iterator 위치에 값을 삽입하거나 삭제해주는 함수이다.</p><h2 id="doubly-linked-list-이중-연결-리스트">Doubly Linked List (이중 연결 리스트) <a href="#doubly-linked-list-이중-연결-리스트" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>1일차에 우리는 Singly Linked List를 배웠다. 티스토리 블로그에는 간단하게 언급한 것 같은데, 여기서 언급했는 지는 기억이 잘 안난다.<br /> 링크드 리스트에는 종류가 보통 3가지가 있는데, 우리가 처음에 배운 단순 연결리스트, 이중 연결리스트, 환형(원형) 연결리스트가 있다.<br /> 이번에 다룰 내용은 실제 C++ STL로 사용되는 이중 연결리스트를 다뤄보겠다.</p><p><img data-src="/image/DS/doublenode.png" alt="doublenode" data-proofer-ignore><br /> 이중 링크드 리스트에 사용되는 노드는 단일 링크드 리스트의 노드에 1개의 주소필드가 추가된다.<br /> 기존의 노드는 next라는 다음 노드를 지시하는 주소필드가 존재했지만 새로 만드는 노드는 prev라는 이전 노드를 지시하는 주소필드가 존재한다. 그렇기 때문에 단순 연결리스트의 한계인 중간에 데이터 삽입하기가 가능해진다.</p><p><img data-src="/image/DS/dll.png" style="width:500px;" data-proofer-ignore><br /></p><p>이중 연결리스트는 삽입과 삭제 함수의 일관성을 위해서 header와 trailer라는 dummy node가 존재한다. header의 prev와 trailer의 next는 모두 NULL값을 가리키고 있다.<br /> 이중 연결리스트를 구현해보면서 자세한 원리를 설명하겠다.</p><h1 id="doubly-linked-list-implementation-이중-연결리스트-구현">Doubly Linked list implementation (이중 연결리스트 구현)</h1><h2 id="node-class-and-prototype">Node class and prototype <a href="#node-class-and-prototype" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>

  <span class="n">Node</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DLinkedList</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">tail</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

  <span class="n">DLinkedList</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">insertFront</span><span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">removeFront</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">insertBack</span><span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">removeBack</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">empty</span><span class="p">();</span>

  <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">);</span>

  <span class="o">~</span><span class="n">DLinkedList</span><span class="p">(){}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>맨 앞이나 맨 뒤에서의 삽입, 삭제 연산은 간단하지만 중간에 삽입하는 함수를 구현하기 위해서는 iterator class를 구현해서 만들어줘야한다. 하지만 iterator를 구현하는게 이 글의 목적이 아니므로 iterator는 생략한다.</p><h2 id="initializer-생성자">initializer (생성자) <a href="#initializer-생성자" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">DLinkedList</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
  <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
  <span class="n">tail</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>이중 링크드 리스트의 생성자에서는 앞서 말한 더미 노드가 구현이 된다. 그래서 head와 tail에 각각 새로운 노드를 만들어준다. 여기서 왜 <code class="language-plaintext highlighter-rouge">head = tail = new Node();</code>냐고 생각이 든다면 한 10초정도 잘 생각해봐라. 그래도 모르겠다면 음… 지금 이걸 공부할 때가 아닌 것 같다.</p><h2 id="empty-function">empty function <a href="#empty-function" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>예외처리를 위해 항상 먼저 만드는 empty함수이다. 원리는 항상 간단하다. head의 다음이 tail이면 빈 경우라고 생각하면된다.</p><h2 id="insertfront-function">insertFront function <a href="#insertfront-function" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">insertFront</span><span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>

  <span class="n">v</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">v</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
  <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>노드를 2개나 변경시켜야하므로 상당히 헷갈리는 과정이 있다. 노드를 연결할 때 순서가 꼬이면 자기자신으로 도는 경우가 발생할 수 있으므로 순서를 잘 생각해야한다.<br /> 이전에 있던 노드를 먼저 변경하면 문제가 발생할 수 있으므로 새 노드를 우선 연결해주는게 좋다.</p><ol><li>삽입을 위한 노드를 새로 만들어준다.<li>새 노드의 next를 head의 next 노드로 연결해준다.<li>새 노드의 prev를 head로 해준다.<li>head노드의 다음 노드의 prev는 v를 가리킨다.<li>head노드의 next는 v를 가리킨다.</ol><p>위의 순서에서 가장 헷갈리는 게 4번과 5번과정인데, 4번이 앞서야 하는 이유는 간단하다. 만약 head 노드의 next를 먼저 바꿔버리면 기존에 head의 다음 노드가 가리키는 이전 노드를 변경할 수 없게된다. 글로는 헷갈리니 아래의 사진을 참고해주길 바란다.</p><p><img data-src="/image/DS/derror.png" style="width:450px;" data-proofer-ignore><br /></p><h2 id="removefront-function">removeFront function <a href="#removefront-function" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">removeFront</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">old</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

  <span class="n">old</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
  <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

  <span class="k">delete</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>앞에서 삭제하는 함수는 어렵지 않다. 미리 삭제하는 노드를 저장해두고 그 노드를 활용해서 node들의 연결 관계를 설정해주면된다. 아마 insertFront보다는 덜 헷갈릴 것 같지만 헷갈린다면 그림을 그려서 확인하면 이해가 될 것이다.</p><p>생각보다 글이 길어지고 있어서 insertBack과 removeBack은 생략하겠다. 한 번 직접 구현해보길 권한다. 원리는 front류 함수들과 비슷하다. 사실 제일 중요한건 단순 insert와 remove이기 때문이다.</p><h2 id="insert-function">insert function <a href="#insert-function" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>

  <span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">getNode</span><span class="p">();</span>

  <span class="n">v</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
  <span class="n">v</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
  <span class="n">curr</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">curr</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>큰 동작원리는 insertFront와 동일하다. <code class="language-plaintext highlighter-rouge">iter.getNode()</code>는 해당 iterator가 지시하는 노드를 가져오는 함수이다. 이 함수의 정확한 활용도는 iter node의 앞에 데이터가 e인 노드를 삽입하는 것이다.<br /> 동작원리가 유사하니 순서도 중요하게 맞춰줘야한다.</p><h2 id="remove-function">remove function <a href="#remove-function" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">del</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">getNode</span><span class="p">();</span>

  <span class="n">del</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">del</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">del</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">del</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

  <span class="k">delete</span> <span class="n">del</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>remove도 기존의 삭제 연산과 동작원리가 유사하다. 이쯤되면 약간 눈치빠른 사람들은 알 수 있는데, 삭제연산은 삽입연산에보다 좀 더 순서의 제한이 적다는 것을 눈치챌 수 있다.<br /> 이유는 간단하다. 새롭게 만들어 주는 노드는 next와 prev를 변경하는 데에 자유로운데, 앞 뒤에 연결관계가 없기때문이다.<br /> 삽입연산은 앞뒤 노드를 기준으로 새로운 연결관계를 만들어 줘야하지만 제거연산은 상대적으로 주소필드 변경이 자유로운 새 노드를 기준으로 동작되므로 삭제연산이 더 간단하다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/datastructure/'>DataStructure</a>, <a href='/categories/c/'>C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/datastructure/" class="post-tag no-text-decoration" >DataStructure</a> <a href="/tags/vector/" class="post-tag no-text-decoration" >Vector</a> <a href="/tags/list/" class="post-tag no-text-decoration" >List</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Data Structure] Vector and List (벡터와 리스트) - Coding Gallery&url=https://cow-coding.github.io/posts/Vector/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Data Structure] Vector and List (벡터와 리스트) - Coding Gallery&u=https://cow-coding.github.io/posts/Vector/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Data Structure] Vector and List (벡터와 리스트) - Coding Gallery&url=https://cow-coding.github.io/posts/Vector/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/coursera2_3/">[MLOps Specialization / Step2] Labeling Data</a><li><a href="/posts/module/">[BoostCamp AI Tech / 심화포스팅] torch.nn.Module 뜯어먹기</a><li><a href="/posts/list/">[Deep Dive Python] 2. List</a><li><a href="/posts/variable/">[Deep Dive Python] 1. Python의 객체와 변수 개념</a><li><a href="/posts/final7/">[BoostCamp AI Tech / Final] Day91 - Airflow setting 및 배치 파이프라인 설계</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai-tech/">AI Tech</a> <a class="post-tag" href="/tags/boostcamp/">BoostCamp</a> <a class="post-tag" href="/tags/naver/">NAVER</a> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/mlops/">MLOps</a> <a class="post-tag" href="/tags/data-engineering/">Data Engineering</a> <a class="post-tag" href="/tags/project/">Project</a> <a class="post-tag" href="/tags/basic/">Basic</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/recommender-system/">Recommender System</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/LinkedList/"><div class="card-body"> <em class="timeago small" date="2020-06-30 00:00:00 +0900" >Jun 30, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Data Structure] Linked List (연결 리스트)</h3><div class="text-muted small"><p> Linked list (연결 리스트) 링크드 리스트와 배열 Linked list (연결 리스트)와 가장 많이 비교되는 자료구조에는 Array (배열)가 있다. 두 자료구조 모두 linear order data structure로, 선형 저장구조를 갖고 있다. 선형 저장구조를 갖고 있다는 의미는 데이터 간의 전후관계가 존재한다는 의미와도 같다. 두 ...</p></div></div></a></div><div class="card"> <a href="/posts/AnalysisAlgorithm/"><div class="card-body"> <em class="timeago small" date="2020-07-03 00:00:00 +0900" >Jul 3, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Data Structure] Analysis of Algorithms (알고리즘 분석)</h3><div class="text-muted small"><p> Algorithm Analysis (알고리즘 분석) Asymtotic Analysis (점근적 분석) 알고리즘을 비교, 분석할 때는 일반적으로 점근적 분석방법을 따른다. 점근적 분석방법은 아래의 과정들로 진행된다. 의사코드 (pseudo code) 연산자 개수 카운트 (primitive operation counting) input s...</p></div></div></a></div><div class="card"> <a href="/posts/Stack/"><div class="card-body"> <em class="timeago small" date="2020-07-04 00:00:00 +0900" >Jul 4, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Data Structure] Stack(스택)</h3><div class="text-muted small"><p> Abstract Data Types (추상 자료형) 추상 자료형 (ADTs)는 한마디로 말하면 알고리즘의 요약본이다. ADT는 correctness와 performance를 독립적으로 생각하게 해줄 수 있다. Correctness는 일반적으로 interface라고도 하는데, input이 들어왔을 때, output의 일치 정확도가 얼마나 높은 가를 말한...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Queue/" class="btn btn-outline-primary" prompt="Older"><p>[Data Structure] Queue(큐)</p></a> <a href="/posts/Tree/" class="btn btn-outline-primary" prompt="Newer"><p>[Data Structure] Tree (트리)</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://cow-coding.github.io/posts/Vector/'; this.page.identifier = '/posts/Vector/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://cow-coding.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/cow-coding">Park Kibum</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai-tech/">AI Tech</a> <a class="post-tag" href="/tags/boostcamp/">BoostCamp</a> <a class="post-tag" href="/tags/naver/">NAVER</a> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/mlops/">MLOps</a> <a class="post-tag" href="/tags/data-engineering/">Data Engineering</a> <a class="post-tag" href="/tags/project/">Project</a> <a class="post-tag" href="/tags/basic/">Basic</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/recommender-system/">Recommender System</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { loader: {load: ['[tex]/color']}, chtml: { scale: 1.2 }, tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ], packages: {'[+]':['color']} } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-163727422-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-163727422-1'); }); </script>
